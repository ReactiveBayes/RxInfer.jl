<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model specification · RxInfer.jl</title><meta name="title" content="Model specification · RxInfer.jl"/><meta property="og:title" content="Model specification · RxInfer.jl"/><meta property="twitter:title" content="Model specification · RxInfer.jl"/><meta name="description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="og:description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="twitter:description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="og:url" content="https://reactivebayes.github.io/RxInfer.jl/manuals/model-specification/"/><meta property="twitter:url" content="https://reactivebayes.github.io/RxInfer.jl/manuals/model-specification/"/><link rel="canonical" href="https://reactivebayes.github.io/RxInfer.jl/manuals/model-specification/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/theme.css" rel="stylesheet" type="text/css"/><link href="../../assets/header.css" rel="stylesheet" type="text/css"/><script src="../../assets/header.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="RxInfer.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="RxInfer.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RxInfer.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../comparison/">RxInfer.jl vs. Others</a></li><li class="is-active"><a class="tocitem" href>Model specification</a><ul class="internal"><li><a class="tocitem" href="#@model-macro"><span><code>@model</code> macro</span></a></li><li><a class="tocitem" href="#A-state-space-model-example"><span>A state space model example</span></a></li><li><a class="tocitem" href="#user-guide-model-specification-node-creation"><span>Relationships between variables</span></a></li><li><a class="tocitem" href="#user-guide-model-specification-visualization"><span>Model structure visualisation</span></a></li><li><a class="tocitem" href="#Node-Contraction"><span>Node Contraction</span></a></li><li><a class="tocitem" href="#Read-also"><span>Read also</span></a></li></ul></li><li><a class="tocitem" href="../constraints-specification/">Constraints specification</a></li><li><a class="tocitem" href="../meta-specification/">Meta specification</a></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Inference specification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../inference/overview/">Overview</a></li><li><a class="tocitem" href="../inference/static/">Static inference</a></li><li><a class="tocitem" href="../inference/streamlined/">Streamline inference</a></li><li><a class="tocitem" href="../inference/initialization/">Initialization</a></li><li><a class="tocitem" href="../inference/autoupdates/">Auto-updates</a></li><li><a class="tocitem" href="../inference/delta-node/">Deterministic nodes</a></li><li><a class="tocitem" href="../inference/nonconjugate/">Non-conjugate inference</a></li><li><a class="tocitem" href="../inference/undefinedrules/">Undefined message update rules</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Inference customization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../customization/custom-node/">Defining a custom node and rules</a></li><li><a class="tocitem" href="../customization/postprocess/">Inference results postprocessing</a></li></ul></li><li><a class="tocitem" href="../debugging/">Debugging</a></li><li><a class="tocitem" href="../migration-guide-v2-v3/">Migration from v2 to v3</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/model-construction/">Model construction</a></li><li><a class="tocitem" href="../../library/bethe-free-energy/">Bethe Free Energy</a></li><li><a class="tocitem" href="../../library/functional-forms/">Functional form constraints</a></li><li><a class="tocitem" href="../../library/exported-methods/">Exported methods</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Basic examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/basic_examples/overview/">Overview</a></li><li><a class="tocitem" href="../../examples/basic_examples/Coin Toss Model/">Coin toss model (Beta-Bernoulli)</a></li><li><a class="tocitem" href="../../examples/basic_examples/Bayesian Linear Regression Tutorial/">Bayesian Linear Regression Tutorial</a></li><li><a class="tocitem" href="../../examples/basic_examples/Kalman filtering and smoothing/">Kalman filtering and smoothing</a></li><li><a class="tocitem" href="../../examples/basic_examples/Predicting Bike Rental Demand/">Predicting Bike Rental Demand</a></li><li><a class="tocitem" href="../../examples/basic_examples/Hidden Markov Model/">How to train your Hidden Markov Model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Advanced examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/advanced_examples/overview/">Overview</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Active Inference Mountain car/">Active Inference Mountain car</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Advanced Tutorial/">Advanced Tutorial</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Assessing People Skills/">Assessing People’s Skills</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Chance Constraints/">Chance-Constrained Active Inference</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Conjugate-Computational Variational Message Passing/">Conjugate-Computational Variational Message Passing (CVI)</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Global Parameter Optimisation/">Global Parameter Optimisation</a></li><li><a class="tocitem" href="../../examples/advanced_examples/GP Regression by SSM/">Solve GP regression by SDE</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Infinite Data Stream/">Infinite Data Stream</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Nonlinear Sensor Fusion/">Nonlinear Sensor Fusion</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Problem specific</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/problem_specific/overview/">Overview</a></li><li><a class="tocitem" href="../../examples/problem_specific/Autoregressive Models/">Autoregressive Models</a></li><li><a class="tocitem" href="../../examples/problem_specific/Gamma Mixture/">Gamma Mixture Model</a></li><li><a class="tocitem" href="../../examples/problem_specific/Gaussian Mixture/">Gaussian Mixture</a></li><li><a class="tocitem" href="../../examples/problem_specific/Hierarchical Gaussian Filter/">Hierarchical Gaussian Filter</a></li><li><a class="tocitem" href="../../examples/problem_specific/Invertible Neural Network Tutorial/">Invertible neural networks: a tutorial</a></li><li><a class="tocitem" href="../../examples/problem_specific/Probit Model (EP)/">Probit Model (EP)</a></li><li><a class="tocitem" href="../../examples/problem_specific/RTS vs BIFM Smoothing/">RTS vs BIFM Smoothing</a></li><li><a class="tocitem" href="../../examples/problem_specific/Simple Nonlinear Node/">Simple Nonlinear Node</a></li><li><a class="tocitem" href="../../examples/problem_specific/Universal Mixtures/">Universal Mixtures</a></li></ul></li><li><a class="tocitem" href="../../contributing/external-examples/">External examples</a></li></ul></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="../../contributing/guide/">Contribution guide</a></li><li><a class="tocitem" href="../../contributing/guidelines/">Contribution guidelines</a></li><li><a class="tocitem" href="../../contributing/new-documentation/">Contributing to the documentation</a></li><li><a class="tocitem" href="../../contributing/new-example/">Contributing to the examples</a></li><li><a class="tocitem" href="../../contributing/new-release/">Publishing a new release</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User guide</a></li><li class="is-active"><a href>Model specification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model specification</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/RxInfer.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/RxInfer.jl/blob/main/docs/src/manuals/model-specification.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="user-guide-model-specification"><a class="docs-heading-anchor" href="#user-guide-model-specification">Model Specification</a><a id="user-guide-model-specification-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification" title="Permalink"></a></h1><p><code>RxInfer</code> largely depends on <code>GraphPPL</code> for model specification. Read extensive documentation regarding the model specification in the corresponding section of <a href="https://reactivebayes.github.io/GraphPPL.jl/stable/"><code>GraphPPL</code> documentation</a>. Here we outline only a small portion of model specification capabilities for beginners.</p><h2 id="@model-macro"><a class="docs-heading-anchor" href="#@model-macro"><code>@model</code> macro</a><a id="@model-macro-1"></a><a class="docs-heading-anchor-permalink" href="#@model-macro" title="Permalink"></a></h2><p>The <code>RxInfer.jl</code> package exports the <code>@model</code> macro for model specification. This <code>@model</code> macro accepts the model specification itself in a form of regular Julia function. </p><p>For example: </p><pre><code class="language-julia hljs">@model function model_name(model_arguments...)
    # model specification here
end</code></pre><p>where <code>model_arguments...</code> may include both hypeparameters and data. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>model_arguments</code> are converted to keyword arguments. Positional arguments in the model specification are not supported.  Thus it is not possible to use Julia&#39;s multiple dispatch for the model arguments.</p></div></div><p>The <code>@model</code> macro returns a regular Julia function (in this example <code>model_name()</code>) which can be executed as usual. The only difference here is that all arguments of the model function are treated as keyword arguments. Upon calling, the model function returns a so-called model generator object, e.g:</p><pre><code class="language-julia hljs">@model function my_model(observation, hyperparameter)
    observations ~ Normal(mean = 0.0, var = hyperparameter)
end</code></pre><pre><code class="language-julia hljs">model = my_model(hyperparameter = 3)</code></pre><p>The model generator is not a real model (yet). For example, in the code above, we haven&#39;t specified anything for the <code>observation</code>.  The generator object allows us to iteratively add extra properties to the model, condition on data, and/or assign extra metadata information without actually materializing the entire graph structure. Read extra information about model generator <a href="../../library/model-construction/#lib-model-construction">here</a>.</p><h2 id="A-state-space-model-example"><a class="docs-heading-anchor" href="#A-state-space-model-example">A state space model example</a><a id="A-state-space-model-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-state-space-model-example" title="Permalink"></a></h2><p>Here we give an example of a probabilistic model before presenting the details of the model specification syntax. The model below is a simple state space model with latent random variables <code>x</code> and noisy observations <code>y</code>.</p><pre><code class="language-julia hljs">@model function state_space_model(y, trend, variance)
    x[1] ~ Normal(mean = 0.0, variance = 100.0)
    y[1] ~ Normal(mean = x[1], variance = variance)
    for i in 2:length(y)
       x[i] ~ Normal(mean = x[i - 1] + trend, variance = 1.0)
       y[i] ~ Normal(mean = x[i], variance = variance)
    end
end</code></pre><p>In this model we assign a prior distribution over latent state <code>x[1]</code>. All subsequent states <code>x[i]</code> depend on <code>x[i - 1]</code> and <code>trend</code> and are modelled  as a simple <a href="https://en.wikipedia.org/wiki/Random_walk#:~:text=Gaussian%20random%20walk,-A%20random%20walk&amp;text=If%20%CE%BC%20is%20nonzero%2C%20the,will%20be%20vs%20%2B%20n%CE%BC.">Gaussian random walk</a>. Observations <code>y</code> are modelled with the <code>Gaussian</code> distribution as well with a  prespecified <code>variance</code> hyperparameter.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>length(y)</code> can be called only if <code>y</code> has an associated data with it. This is not always the case, for example it is possible to instantiate the  model lazily before the data becomes available. In such situations, <code>length(y)</code> will throw an error.</p></div></div><h3 id="user-guide-model-specification-hyperparameters"><a class="docs-heading-anchor" href="#user-guide-model-specification-hyperparameters">Hyperparameters</a><a id="user-guide-model-specification-hyperparameters-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-hyperparameters" title="Permalink"></a></h3><p>Any constant passed to a model as a model argument will be automatically converted to a corresponding constant node in the model&#39;s graph.</p><pre><code class="language-julia hljs">model = state_space_model(trend = 3.0, variance = 1.0)</code></pre><p>In this example we instantiate a model generator with <code>trend</code> and <code>variance</code> parameters <em>clamped</em> to <code>3.0</code> and <code>1.0</code> respectively. That means  that no inference will be performed for those parameters and some of the expressions within the model structure might be simplified and compiled-out.</p><h3 id="user-guide-model-specification-conditioning"><a class="docs-heading-anchor" href="#user-guide-model-specification-conditioning">Conditioning on data</a><a id="user-guide-model-specification-conditioning-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-conditioning" title="Permalink"></a></h3><p>To fully complete model specification we need to specify <code>y</code>. In this example, <code>y</code> is playing a role of observations. <code>RxInfer</code> provides a convenient mechanism to pass data values to the model with the <code>|</code> operator.</p><pre><code class="language-julia hljs">conditioned = model | (y = [ 0.0, 1.0, 2.0 ], )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">state_space_model(trend = 3.0, variance = 1.0) conditioned on: 
  y = [0.0, 1.0, 2.0]
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The conditioning on data is a feature of <code>RxInfer</code>, not <code>GraphPPL</code>.</p></div></div><p>In the example above we conditioned on data in a form of the <code>NamedTuple</code>, but it is also possible to  condition on a dictionary where keys represent names of the corresponding model arguments:</p><pre><code class="language-julia hljs">data        = Dict(:y =&gt; [ 0.0, 1.0, 2.0 ])
conditioned = model | data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">state_space_model(trend = 3.0, variance = 1.0) conditioned on: 
  y = [0.0, 1.0, 2.0]
</code></pre><p>Sometimes it might be useful to indicate that some arguments are data (thus condition on them) before the actual data becomes available. This situation may occur during <a href="../inference/streamlined/#manual-online-inference">reactive inference</a>, when data becomes available <em>after</em> model creation. <code>RxInfer</code> provides a special structure called <a href="../../library/model-construction/#RxInfer.DeferredDataHandler"><code>RxInfer.DeferredDataHandler</code></a>, which can be used instead of the real data.</p><p>For the example above, however, we cannot simply do the following:</p><pre><code class="language-julia hljs">model | (y = RxInfer.DeferredDataHandler(), )</code></pre><p>because we use <code>length(y)</code> in the model and this is only possible if <code>y</code> has an associated data.  We could adjust the model specification a bit, by adding the extra <code>n</code> parameter to the list of arguments:</p><pre><code class="language-julia hljs">@model function state_space_model_with_n(y, n, trend, variance)
    x[1] ~ Normal(mean = 0.0, variance = 100.0)
    y[1] ~ Normal(mean = x[1], variance = variance)
    for i in 2:n
       x[i] ~ Normal(mean = x[i - 1] + trend, variance = 1.0)
       y[i] ~ Normal(mean = x[i], variance = variance)
    end
end</code></pre><p>For such model, we can safely condition on <code>y</code> without providing actual data for it, but using the <a href="../../library/model-construction/#RxInfer.DeferredDataHandler"><code>RxInfer.DeferredDataHandler</code></a> instead:</p><pre><code class="language-julia hljs">state_space_model_with_n(trend = 3.0, variance = 1.0, n = 10) | (
    y = RxInfer.DeferredDataHandler(),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">state_space_model_with_n(trend = 3.0, variance = 1.0, n = 10) conditioned on: 
  y = [ deffered data ]
</code></pre><p>Read more information about condition on data in <a href="../../library/model-construction/#lib-model-construction-conditioning">this section</a> of the documentation.</p><h3 id="user-guide-model-specification-random-variables"><a class="docs-heading-anchor" href="#user-guide-model-specification-random-variables">Latent variables</a><a id="user-guide-model-specification-random-variables-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-random-variables" title="Permalink"></a></h3><p>Latent variables are being created with the <code>~</code> operator and can be read as <em>is distributed as</em>.  For example, to create a latent variable <code>y</code> which is modeled by a <a href="https://en.wikipedia.org/wiki/Normal_distribution">Normal</a> distribution,  where its mean and variance are controlled by the random variables <code>m</code> and <code>v</code> respectively, we define</p><pre><code class="language-julia hljs">y ~ Normal(mean = m, variance = v)</code></pre><p>In the example above</p><pre><code class="language-julia hljs">x[1] ~ Normal(mean = 0.0, variance = 100.0)</code></pre><p>indicates that <code>x₁</code> is distributed as <a href="https://en.wikipedia.org/wiki/Normal_distribution">Normal</a> distribution. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>RxInfer.jl</code> package uses the <code>~</code> operator for modelling both stochastic and deterministic relationships between random variables. However, <code>GraphPPL.jl</code> also allows to use <code>:=</code> operator for deterministic relationships.</p></div></div><h2 id="user-guide-model-specification-node-creation"><a class="docs-heading-anchor" href="#user-guide-model-specification-node-creation">Relationships between variables</a><a id="user-guide-model-specification-node-creation-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-node-creation" title="Permalink"></a></h2><p>In probabilistic models based on graphs, factor nodes are used to define a relationship between random variables and/or constants and data variables. A factor node defines a probability distribution over selected latent or data variables. The <code>~</code> operator not only creates a latent variable but also  defines a functional relatinship of it with other variables and creates a factor node as a result.</p><p>In the example above</p><pre><code class="language-julia hljs">x[1] ~ Normal(mean = 0.0, variance = 100.0)</code></pre><p>not only creates a latent variable <code>x₁</code> but also a factor node <code>Normal</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Generally it is not necessary to label all the arguments with their names, as <code>mean = ...</code> or <code>variance = ...</code> and many factor nodes  do not require it explicitly. However, for nodes, which have many different useful parametrizations (e.g. <code>Normal</code>) labeling the arguments  is a requirement that helps to avoid any possible confusion. Read more about <code>Distributions</code> compatibility <a href="#user-guide-model-specification-distributions">here</a>.</p></div></div><h3 id="user-guide-model-specification-node-creation-deterministic"><a class="docs-heading-anchor" href="#user-guide-model-specification-node-creation-deterministic">Deterministic relationships</a><a id="user-guide-model-specification-node-creation-deterministic-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-node-creation-deterministic" title="Permalink"></a></h3><p>In contrast to other probabilistic programming languages in Julia, <code>RxInfer</code> does not allow use of <code>=</code> operator for creating deterministic relationships between (latent)variables.  Instead, we can use <code>:=</code> operator for this purpose. For example:</p><pre><code class="language-julia hljs">t ~ Normal(mean = 0.0, variance = 1.0)
x := exp(t) # x is linked deterministically to t
y ~ Normal(mean = x, variance = 1.0)</code></pre><p>Using <code>x = exp(t)</code> directly would be incorrect and most likely would result in an <code>MethodError</code> because <code>t</code> does not have a definitive value at the model creation time  (remember that our models create a factor graph under the hood and latent states do not have a value until the inference is performed). At the model creation time,  <code>t</code> holds a reference to a node in the graph, instead of an actual value sample from the <code>Normal</code> distribution.</p><h3 id="user-guide-model-specification-node-creation-control-flow"><a class="docs-heading-anchor" href="#user-guide-model-specification-node-creation-control-flow">Control flow statements</a><a id="user-guide-model-specification-node-creation-control-flow-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-node-creation-control-flow" title="Permalink"></a></h3><p>In general, it is possible to use any Julia code within model specification function, including control flow statements, such as <code>for</code>, <code>while</code> and <code>if</code> statements. However, it is not possible to use any latent states within such statements. This is due to the fact that it is necessary to know exactly the structure of the graph before the inference. Thus it is <strong>not possible</strong> to write statements like:</p><pre><code class="language-julia hljs">c ~ Categorical([ 1/2, 1/2 ])
# This is NOT possible in `RxInfer`&#39;s model specification language
if c &gt; 1
# ...
end</code></pre><p>since <code>c</code> must be statically known upon graph creation.</p><h3 id="user-guide-model-specification-node-creation-anonymous"><a class="docs-heading-anchor" href="#user-guide-model-specification-node-creation-anonymous">Anonymous factor nodes and latent variables</a><a id="user-guide-model-specification-node-creation-anonymous-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-node-creation-anonymous" title="Permalink"></a></h3><p>The <code>@model</code> macro automatically resolves any inner function calls into anonymous factor nodes and latent variables.  For example the following:</p><pre><code class="language-julia hljs">y ~ Normal(
    mean = Normal(mean = 0.0, variance = 1.0), 
    precision = Gamma(shape = 1.0, rate = 1.0)
)</code></pre><p>is equivalent to</p><pre><code class="language-julia hljs">tmp1 ~ Normal(mean = 0.0, variance = 1.0)
tmp2 ~ Gamma(shape = 1.0, rate = 1.0)
y    ~ Normal(mean = tmp1, precision = tmp2)</code></pre><p>The inference backend still performs inference for anonymous latent variables, however, there it does not provide an easy way to obtain posteriors for them. Note that the inference backend will try to optimize deterministic function calls in the case where all arguments are known in advance. For example:</p><pre><code class="language-julia hljs">y ~ Normal(mean = 0.0, variance = inv(2.0))</code></pre><p>should not create an extra factor node for the <code>inv</code>, since <code>inv</code> is a deterministic function and all arguments are known in advance. The same situation applies in case of complex initializations involving different types, as in:</p><pre><code class="language-julia hljs">y ~ MvNormal(mean = zeros(3), covariance = Matrix(Diagonal(ones(3))))</code></pre><p>In this case, the expression <code>Matrix(Diagonal(ones(3)))</code> can (and will) be precomputed upon model creation and does not require to perform probabilistic inference.</p><h3 id="user-guide-model-specification-node-creation-indexing"><a class="docs-heading-anchor" href="#user-guide-model-specification-node-creation-indexing">Indexing operations</a><a id="user-guide-model-specification-node-creation-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-node-creation-indexing" title="Permalink"></a></h3><p>The <code>ref</code> expressions, such as <code>x[i]</code>, are handled in a special way. Technically, in Julia, the <code>x[i]</code> call is translated to a function call <code>getindex(x, i)</code>. Thus the <code>@model</code> macro should create a factor node for the <code>getindex</code> function, but this won&#39;t happen in practice because this case is treated separately. This means that the model parser will not create unnecessary nodes when only simple indexing is involved. That also means that all expressions inside <code>x[...]</code> list are left untouched during model parsing. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is not allowed to use latent variables within square brackets in the model specification or for control flow statements such as <code>if</code>, <code>for</code> or <code>while</code>.</p></div></div><h3 id="user-guide-model-specification-node-creation-broadcasting"><a class="docs-heading-anchor" href="#user-guide-model-specification-node-creation-broadcasting">Broadcasting syntax</a><a id="user-guide-model-specification-node-creation-broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-node-creation-broadcasting" title="Permalink"></a></h3><p><code>GraphPPL</code> support broadcasting for <code>~</code> operator in the exact same way as Julia itself.  A user is free to write an expression of the following form:</p><pre><code class="language-julia hljs">m  ~ Normal(mean = 0.0, precision = 0.0001)
t  ~ Gamma(shape = 1.0, rate = 1.0)
y .~ Normal(mean = m, precision = t)</code></pre><p>More complex expressions are also allowed:</p><pre><code class="language-julia hljs">w         ~ Wishart(3, diageye(2))
x[1]      ~ MvNormal(mean = zeros(2), precision = diageye(2))
x[2:end] .~ A .* x[1:end-1] # &lt;- State-space model with transition matrix A
y        .~ MvNormal(mean = x, precision = w) # &lt;- Observations with unknown precision matrix</code></pre><p>Note, however, that shapes of all variables that take part in the broadcasting operation must be defined in advance. That means that it is not possible to  use broadcasting with <a href="#user-guide-model-specification-conditioning">deffered data</a>. Read more about how broadcasting machinery works in Julia in <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">the official documentation</a>.</p><h3 id="user-guide-model-specification-distributions"><a class="docs-heading-anchor" href="#user-guide-model-specification-distributions"><code>Distributions.jl</code> compatibility</a><a id="user-guide-model-specification-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-distributions" title="Permalink"></a></h3><p>For some factor nodes we rely on the syntax from <code>Distributions.jl</code> to make it easy to adopt <code>RxInfer.jl</code> for these users. These nodes include for example the <a href="https://en.wikipedia.org/wiki/Beta_distribution"><code>Beta</code></a> and <a href="https://en.wikipedia.org/wiki/Wishart_distribution"><code>Wishart</code></a> distributions. These nodes can be created using the <code>~</code> syntax with the arguments as specified in <code>Distributions.jl</code>. Unfortunately, we <code>RxInfer.jl</code> is not yet compatible with all possible distributions to be used as factor nodes. If you feel that you would like to see another node implemented, please file an issue.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To quickly check the list of all available factor nodes that can be used in the model specification language call <code>?ReactiveMP.is_predefined_node</code> or <code>Base.doc(ReactiveMP.is_predefined_node)</code>.</p></div></div><p>Specifically for the Gaussian/Normal case we have custom implementations that yield a higher computational efficiency and improved stability in comparison to <code>Distributions.jl</code> as these are optimized for sampling operations. Our aliases for these distributions therefore do not correspond to the implementations from <code>Distributions.jl</code>. However, our model specification language is compatible with syntax from <code>Distributions.jl</code> for normal distributions, which will be automatically converted. <code>RxInfer</code> has its own implementation because of the following 3 reasons:</p><ol><li><code>Distributions.jl</code> constructs normal distributions by saving the corresponding covariance matrices in a <code>PDMat</code> object from <code>PDMats.jl</code>. This construction always computes the Cholesky decompositions of the covariance matrices, which is very convenient for sampling-based procedures. However, in <code>RxInfer.jl</code> we mostly base our computations on analytical expressions which do not always need to compute the Cholesky decomposition. In order to reduce the overhead that <code>Distributions.jl</code> introduces, we therefore have custom implementations.</li><li>Depending on the update rules, we might favor different parameterizations of the normal distributions. <code>ReactiveMP.jl</code> has quite a variety in parameterizations that allow us to efficient computations where we convert between parameterizations as little as possible.</li><li>In certain situations we value stability a lot, especially when inverting matrices. <code>PDMats.jl</code>, and hence <code>Distributions.jl</code>, is not capable to fulfill all needs that we have here. Therefore we use <code>PositiveFactorizations.jl</code> to cope with the corner-cases.</li></ol><h2 id="user-guide-model-specification-visualization"><a class="docs-heading-anchor" href="#user-guide-model-specification-visualization">Model structure visualisation</a><a id="user-guide-model-specification-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-visualization" title="Permalink"></a></h2><p>It is also possible to visualize the model structure after conditioning on data. For that we need two extra packages installed: <code>Cairo</code> and <code>GraphPlot</code>. Note, that those packages are not included in the <code>RxInfer</code> package and must be installed separately.</p><pre><code class="language-julia hljs">using Cairo, GraphPlot

# `Create` the actual graph of the model conditioned on the data
model = RxInfer.create_model(conditioned)

# Call `gplot` function from `GraphPlot` to visualise the structure of the graph
GraphPlot.gplot(RxInfer.getmodel(model))</code></pre><img src="0768529b.svg" alt="Example block output"/><h2 id="Node-Contraction"><a class="docs-heading-anchor" href="#Node-Contraction">Node Contraction</a><a id="Node-Contraction-1"></a><a class="docs-heading-anchor-permalink" href="#Node-Contraction" title="Permalink"></a></h2><p>RxInfer&#39;s model specification extension for GraphPPL supports a feature called <em>node contraction</em>. This feature allows you to <em>contract</em> (or <em>replace</em>) a submodel with a corresponding factor node. Node contraction can be useful in several scenarios:</p><ul><li>When running inference in a submodel is computationally expensive</li><li>When a submodel contains many variables whose inference results are not of primary importance</li><li>When specialized message passing update rules can be derived for variables in the Markov blanket of the submodel</li></ul><p>Let&#39;s illustrate this concept with a simple example. We&#39;ll first create a basic submodel and then allow the inference backend to replace it with a corresponding node that has well-defined message update rules.</p><pre><code class="language-julia hljs">using RxInfer, Plots

@model function ShiftedNormal(data, mean, precision, shift)
    shifted_mean := mean + shift
    data ~ Normal(mean = shifted_mean, precision = precision)
end

@model function Model(data, precision, shift)
    mean ~ Normal(mean = 15.0, var = 1.0)
    data ~ ShiftedNormal(mean = mean, precision = precision, shift = shift)
end

result = infer(
    model = Model(precision = 1.0, shift = 1.0),
    data  = (data = 10.0, )
)

plot(title = &quot;Inference results over `mean`&quot;)
plot!(0:0.1:20.0, (x) -&gt; pdf(NormalMeanVariance(15.0, 1.0), x), label = &quot;prior&quot;, fill = 0, fillalpha = 0.2)
plot!(0:0.1:20.0, (x) -&gt; pdf(result.posteriors[:mean], x), label = &quot;posterior&quot;, fill = 0, fillalpha = 0.2)
vline!([ 10.0 ], label = &quot;data point&quot;)</code></pre><img src="b8bbf273.svg" alt="Example block output"/><p>As we can see, we can run inference on this model. We can also visualize the model&#39;s structure, as shown in the <a href="#user-guide-model-specification-visualization">Model structure visualisation</a> section.</p><pre><code class="language-julia hljs">using Cairo, GraphPlot

GraphPlot.gplot(getmodel(result.model))</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.2"
     width="100mm" height="100mm" viewBox="0 0 100 100"
     stroke="none"
     fill="%23000000"
     stroke-width="0.3"
     font-size="3.88"
>
<defs>
  <marker id="arrow" markerWidth="15" markerHeight="7" refX="5" refY="3.5" orient="auto" markerUnits="strokeWidth">
    <path d="M0,0 L15,3.5 L0,7 z" stroke="context-stroke" fill="context-stroke"/>
  </marker>
</defs>
<g fill="%23000000" fill-opacity="0.000" id="img-f25d250b-1">
  <g transform="translate(50,50)">
    <path d="M-50,-50 L50,-50 50,50 -50,50  z" class="primitive"/>
  </g>
</g>
<g stroke-width="0.95" stroke="%23D3D3D3" id="img-f25d250b-2">
</g>
<g stroke-width="0.95" stroke="%23D3D3D3" id="img-f25d250b-3">
  <g transform="translate(27.36,34.72)">
    <path fill="none" d="M4.39,5.7 L-4.39,-5.7 " class="primitive"/>
  </g>
  <g transform="translate(40.28,51.56)">
    <path fill="none" d="M-4.52,-5.92 L4.52,5.92 " class="primitive"/>
  </g>
  <g transform="translate(19.64,17.37)">
    <path fill="none" d="M-0.85,-5.78 L0.85,5.78 " class="primitive"/>
  </g>
  <g transform="translate(14.65,25.4)">
    <path fill="none" d="M-3.06,-0.49 L3.06,0.49 " class="primitive"/>
  </g>
  <g transform="translate(55.23,64.36)">
    <path fill="none" d="M5.48,2.78 L-5.48,-2.78 " class="primitive"/>
  </g>
  <g transform="translate(71.61,72.61)">
    <path fill="none" d="M-5.01,-2.51 L5.01,2.51 " class="primitive"/>
  </g>
  <g transform="translate(43.84,67.63)">
    <path fill="none" d="M-1.76,4.47 L1.76,-4.47 " class="primitive"/>
  </g>
  <g transform="translate(83.43,84.13)">
    <path fill="none" d="M2.36,4.61 L-2.36,-4.61 " class="primitive"/>
  </g>
  <g transform="translate(85.61,73.62)">
    <path fill="none" d="M3.09,-1.52 L-3.09,1.52 " class="primitive"/>
  </g>
</g>
<g fill="%23D3D3D3" id="img-f25d250b-4">
</g>
<g fill="%23D3D3D3" id="img-f25d250b-5">
</g>
<g font-size="4" fill="%23000000" id="img-f25d250b-6">
</g>
<g stroke-width="0" stroke="%23000000" stroke-opacity="0.000" fill="%2340E0D0" id="img-f25d250b-7">
  <g transform="translate(33.76,43.03)">
    <circle cx="0" cy="0" r="3.16" class="primitive"/>
  </g>
  <g transform="translate(18.31,8.33)">
    <circle cx="0" cy="0" r="3.16" class="primitive"/>
  </g>
  <g transform="translate(8.33,24.38)">
    <circle cx="0" cy="0" r="3.16" class="primitive"/>
  </g>
  <g transform="translate(20.96,26.42)">
    <circle cx="0" cy="0" r="3.16" class="primitive"/>
  </g>
  <g transform="translate(63.65,68.62)">
    <circle cx="0" cy="0" r="3.16" class="primitive"/>
  </g>
  <g transform="translate(40.87,75.16)">
    <circle cx="0" cy="0" r="3.16" class="primitive"/>
  </g>
  <g transform="translate(46.81,60.1)">
    <circle cx="0" cy="0" r="3.16" class="primitive"/>
  </g>
  <g transform="translate(87.3,91.67)">
    <circle cx="0" cy="0" r="3.16" class="primitive"/>
  </g>
  <g transform="translate(91.67,70.65)">
    <circle cx="0" cy="0" r="3.16" class="primitive"/>
  </g>
  <g transform="translate(79.56,76.59)">
    <circle cx="0" cy="0" r="3.16" class="primitive"/>
  </g>
</g>
<g font-family="Helvetica" font-size="4" fill="%23000000" id="img-f25d250b-8">
  <g transform="translate(33.76,43.03)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">mean</text>
    </g>
  </g>
  <g transform="translate(18.31,8.33)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">constvar</text>
    </g>
  </g>
  <g transform="translate(8.33,24.38)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">constvar</text>
    </g>
  </g>
  <g transform="translate(20.96,26.42)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">NormalMeanVariance</text>
    </g>
  </g>
  <g transform="translate(63.65,68.62)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">shifted_mean</text>
    </g>
  </g>
  <g transform="translate(40.87,75.16)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">constvar</text>
    </g>
  </g>
  <g transform="translate(46.81,60.1)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">+</text>
    </g>
  </g>
  <g transform="translate(87.3,91.67)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">data</text>
    </g>
  </g>
  <g transform="translate(91.67,70.65)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">constvar</text>
    </g>
  </g>
  <g transform="translate(79.56,76.59)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">NormalMeanPrecision</text>
    </g>
  </g>
</g>
<g font-family="Helvetica" font-size="4" fill="%23000000" id="img-f25d250b-9">
  <g transform="translate(50,0)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em"></text>
    </g>
  </g>
</g>
</svg>
'/><p>Now, let&#39;s create an optimized version of the <code>ShiftedNormal</code> submodel as a standalone node with its own message passing update rules.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Creating correct message passing update rules is beyond the scope of this section. For more information about custom message passing update rules, refer to the <a href="../customization/custom-node/#create-node">Custom Node</a> section.</p></div></div><pre><code class="language-julia hljs">@node typeof(ShiftedNormal) Stochastic [ data, mean, precision, shift ]

@rule typeof(ShiftedNormal)(:mean, Marginalisation) (q_data::PointMass, q_precision::PointMass, q_shift::PointMass, ) = begin
    return @call_rule NormalMeanPrecision(:μ, Marginalisation) (q_out = PointMass(mean(q_data) - mean(q_shift)), q_τ = q_precision)
end

result_with_contraction = infer(
    model = Model(precision = 1.0, shift = 1.0),
    data  = (data = 10.0, ),
    allow_node_contraction = true
)

plot(title = &quot;Inference results over `mean` with node contraction&quot;)
plot!(0:0.1:20.0, (x) -&gt; pdf(NormalMeanVariance(15.0, 1.0), x), label = &quot;prior&quot;, fill = 0, fillalpha = 0.2)
plot!(0:0.1:20.0, (x) -&gt; pdf(result_with_contraction.posteriors[:mean], x), label = &quot;posterior&quot;, fill = 0, fillalpha = 0.2)
vline!([ 10.0 ], label = &quot;data point&quot;)</code></pre><img src="ae28ebea.svg" alt="Example block output"/><p>As you can see, the inference result is identical to the previous case. However, the structure of the model is different:</p><pre><code class="language-julia hljs">GraphPlot.gplot(getmodel(result_with_contraction.model))</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.2"
     width="100mm" height="100mm" viewBox="0 0 100 100"
     stroke="none"
     fill="%23000000"
     stroke-width="0.3"
     font-size="3.88"
>
<defs>
  <marker id="arrow" markerWidth="15" markerHeight="7" refX="5" refY="3.5" orient="auto" markerUnits="strokeWidth">
    <path d="M0,0 L15,3.5 L0,7 z" stroke="context-stroke" fill="context-stroke"/>
  </marker>
</defs>
<g fill="%23000000" fill-opacity="0.000" id="img-6289a05b-1">
  <g transform="translate(50,50)">
    <path d="M-50,-50 L50,-50 50,50 -50,50  z" class="primitive"/>
  </g>
</g>
<g stroke-width="1.06" stroke="%23D3D3D3" id="img-6289a05b-2">
</g>
<g stroke-width="1.06" stroke="%23D3D3D3" id="img-6289a05b-3">
  <g transform="translate(39.93,59.88)">
    <path fill="none" d="M7.82,-7.26 L-7.82,7.26 " class="primitive"/>
  </g>
  <g transform="translate(61.24,40.04)">
    <path fill="none" d="M-8.1,7.57 L8.1,-7.57 " class="primitive"/>
  </g>
  <g transform="translate(27.43,80.65)">
    <path fill="none" d="M-1.32,7.39 L1.32,-7.39 " class="primitive"/>
  </g>
  <g transform="translate(18.87,70.33)">
    <path fill="none" d="M-6.86,0.45 L6.86,-0.45 " class="primitive"/>
  </g>
  <g transform="translate(68.81,19.15)">
    <path fill="none" d="M-2.17,-7.28 L2.17,7.28 " class="primitive"/>
  </g>
  <g transform="translate(80.48,22.1)">
    <path fill="none" d="M5.75,-5.35 L-5.75,5.35 " class="primitive"/>
  </g>
  <g transform="translate(81.85,34.97)">
    <path fill="none" d="M6.53,3.34 L-6.53,-3.34 " class="primitive"/>
  </g>
</g>
<g fill="%23D3D3D3" id="img-6289a05b-4">
</g>
<g fill="%23D3D3D3" id="img-6289a05b-5">
</g>
<g font-size="4" fill="%23000000" id="img-6289a05b-6">
</g>
<g stroke-width="0" stroke="%23000000" stroke-opacity="0.000" fill="%2340E0D0" id="img-6289a05b-7">
  <g transform="translate(50.45,50.12)">
    <circle cx="0" cy="0" r="3.54" class="primitive"/>
  </g>
  <g transform="translate(25.46,91.67)">
    <circle cx="0" cy="0" r="3.54" class="primitive"/>
  </g>
  <g transform="translate(8.33,71.03)">
    <circle cx="0" cy="0" r="3.54" class="primitive"/>
  </g>
  <g transform="translate(29.4,69.64)">
    <circle cx="0" cy="0" r="3.54" class="primitive"/>
  </g>
  <g transform="translate(65.59,8.33)">
    <circle cx="0" cy="0" r="3.54" class="primitive"/>
  </g>
  <g transform="translate(88.92,14.24)">
    <circle cx="0" cy="0" r="3.54" class="primitive"/>
  </g>
  <g transform="translate(91.67,39.98)">
    <circle cx="0" cy="0" r="3.54" class="primitive"/>
  </g>
  <g transform="translate(72.04,29.96)">
    <circle cx="0" cy="0" r="3.54" class="primitive"/>
  </g>
</g>
<g font-family="Helvetica" font-size="4" fill="%23000000" id="img-6289a05b-8">
  <g transform="translate(50.45,50.12)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">mean</text>
    </g>
  </g>
  <g transform="translate(25.46,91.67)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">constvar</text>
    </g>
  </g>
  <g transform="translate(8.33,71.03)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">constvar</text>
    </g>
  </g>
  <g transform="translate(29.4,69.64)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">NormalMeanVariance</text>
    </g>
  </g>
  <g transform="translate(65.59,8.33)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">data</text>
    </g>
  </g>
  <g transform="translate(88.92,14.24)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">constvar</text>
    </g>
  </g>
  <g transform="translate(91.67,39.98)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">constvar</text>
    </g>
  </g>
  <g transform="translate(72.04,29.96)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em">ShiftedNormal</text>
    </g>
  </g>
</g>
<g font-family="Helvetica" font-size="4" fill="%23000000" id="img-6289a05b-9">
  <g transform="translate(50,0)">
    <g class="primitive">
      <text text-anchor="middle" dy="0.35em"></text>
    </g>
  </g>
</g>
</svg>
'/><p>With node contraction, we no longer have access to the variables defined inside the <code>ShiftedNormal</code> submodel, as it has been contracted to a single factor node. It&#39;s worth noting that this feature heavily relies on existing message passing update rules for the submodel. However, it can also be combined with another useful inference technique <a href="../inference/undefinedrules/#inference-undefinedrules">where no explicit message passing update rules are required</a>.</p><p>We can also verify that node contraction indeed improves the performance of the inference:</p><pre><code class="language-julia hljs">using BenchmarkTools

benchmark_without_contraction = @benchmark infer(
    model = Model(precision = 1.0, shift = 1.0),
    data  = (data = 10.0, )
)

benchmark_with_contraction = @benchmark infer(
    model = Model(precision = 1.0, shift = 1.0),
    data  = (data = 10.0, ),
    allow_node_contraction = true
)</code></pre><p>Let&#39;s examine the benchmark results:</p><pre><code class="language-julia hljs">benchmark_without_contraction</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">181.419 μs</span></span> … <span class="sgr35">737.307 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">220.933 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">220.502 μs</span></span> ± <span class="sgr32"> 19.573 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

         ▁▁             ▁▄▅██<span class="sgr34">▇</span>█▆▄▂                               
  ▂▂▂▃▄▆████▅▅▄▄▃▃▂▃▃▄▅▆█████<span class="sgr34">█</span>████▇▆▅▄▅▅▅▆▆▆▆▅▅▄▄▃▃▃▂▂▂▂▂▂▂▂▁▂▂ ▄
  181 μs<span class="sgr90">           Histogram: frequency by time</span>          270 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">93.66 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">1433</span>.</code></pre><pre><code class="language-julia hljs">benchmark_with_contraction</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">113.622 μs</span></span> … <span class="sgr35">588.599 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">137.752 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">136.930 μs</span></span> ± <span class="sgr32"> 14.889 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

    ▄▅▂             ▃▄▆<span class="sgr32">▇</span><span class="sgr34">█</span>█▇▇▃▁                                   
  ▂▆███▇▆▅▄▃▃▃▃▃▄▅▇▇███<span class="sgr32">█</span><span class="sgr34">█</span>█████▇▅▄▃▃▃▂▃▃▃▃▃▃▃▃▃▃▂▂▂▁▂▁▁▁▁▁▁▁▁▁▁▁ ▄
  114 μs<span class="sgr90">           Histogram: frequency by time</span>          181 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">68.27 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">977</span>.</code></pre><p>As we can see, the inference with node contraction runs faster due to the simplified model structure and optimized message update rules.  This performance improvement is reflected in reduced execution time and fewer memory allocations.</p><h3 id="user-guide-model-specification-node-creation-options"><a class="docs-heading-anchor" href="#user-guide-model-specification-node-creation-options">Node creation options</a><a id="user-guide-model-specification-node-creation-options-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-model-specification-node-creation-options" title="Permalink"></a></h3><p><code>GraphPPL</code> allows to pass optional arguments to the node creation constructor with the <code>where { options...  }</code> options specification syntax.</p><p>Example:</p><pre><code class="language-julia hljs">y ~ Normal(mean = y_mean, var = y_var) where { meta = ... }</code></pre><p>A list of the available options specific to the <code>ReactiveMP</code> inference engine is presented below.</p><h4 id="Metadata-option"><a class="docs-heading-anchor" href="#Metadata-option">Metadata option</a><a id="Metadata-option-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata-option" title="Permalink"></a></h4><p>Is is possible to pass any extra metadata to a factor node with the <code>meta</code> option. Metadata can be later accessed in message computation rules.</p><pre><code class="language-julia hljs">z ~ f(x, y) where { meta = Linearization() }
d ~ g(a, b) where { meta = Unscented() }</code></pre><p>This option might be useful to change message passing rules around a specific factor node. Read more about this feature in <a href="../meta-specification/#user-guide-meta-specification">Meta Specification</a> section.</p><h4 id="Dependencies-option"><a class="docs-heading-anchor" href="#Dependencies-option">Dependencies option</a><a id="Dependencies-option-1"></a><a class="docs-heading-anchor-permalink" href="#Dependencies-option" title="Permalink"></a></h4><p>A user can modify default computational pipeline of a node with the <code>dependencies</code> options.  Read more about different options in the <a href="https://reactivebayes.github.io/ReactiveMP.jl/stable/"><code>ReactiveMP.jl</code> documentation</a>.</p><pre><code class="language-julia hljs">y[k - 1] ~ Probit(x[k]) where {
    # This specification indicates that in order to compute an outbound message from the `in` interface
    # We need an inbound message from the same edge initialized to `NormalMeanPrecision(0.0, 1.0)`
    dependencies = RequireMessageFunctionalDependencies(in = NormalMeanPrecision(0.0, 1.0))
}</code></pre><h2 id="Read-also"><a class="docs-heading-anchor" href="#Read-also">Read also</a><a id="Read-also-1"></a><a class="docs-heading-anchor-permalink" href="#Read-also" title="Permalink"></a></h2><ul><li><a href="../constraints-specification/#user-guide-constraints-specification">Constraints specification</a></li><li><a href="../meta-specification/#user-guide-meta-specification">Meta specification</a></li><li><a href="../inference/overview/#user-guide-inference-execution">Inference execution</a></li><li><a href="../debugging/#user-guide-debugging">Debugging inference</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../comparison/">« RxInfer.jl vs. Others</a><a class="docs-footer-nextpage" href="../constraints-specification/">Constraints specification »</a><div class="flexbox-break"></div><p class="footer-message">Created in <a href="https://biaslab.github.io/">BIASlab</a>, maintained by <a href="https://github.com/ReactiveBayes">ReactiveBayes</a>, powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 3 October 2024 11:06">Thursday 3 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
