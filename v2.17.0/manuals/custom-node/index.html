<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Defining a custom node and rules · RxInfer.jl</title><meta name="title" content="Defining a custom node and rules · RxInfer.jl"/><meta property="og:title" content="Defining a custom node and rules · RxInfer.jl"/><meta property="twitter:title" content="Defining a custom node and rules · RxInfer.jl"/><meta name="description" content="Documentation for RxInfer.jl."/><meta property="og:description" content="Documentation for RxInfer.jl."/><meta property="twitter:description" content="Documentation for RxInfer.jl."/><meta property="og:url" content="https://reactivebayes.github.io/RxInfer.jl/manuals/custom-node/"/><meta property="twitter:url" content="https://reactivebayes.github.io/RxInfer.jl/manuals/custom-node/"/><link rel="canonical" href="https://reactivebayes.github.io/RxInfer.jl/manuals/custom-node/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/theme.css" rel="stylesheet" type="text/css"/><link href="../../assets/header.css" rel="stylesheet" type="text/css"/><script src="../../assets/header.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="RxInfer.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="RxInfer.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RxInfer.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../comparison/">RxInfer.jl vs. Others</a></li><li><a class="tocitem" href="../model-specification/">Model specification</a></li><li><a class="tocitem" href="../constraints-specification/">Constraints specification</a></li><li><a class="tocitem" href="../meta-specification/">Meta specification</a></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Inference specification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../inference/overview/">Overview</a></li><li><a class="tocitem" href="../inference/infer/">Static vs Streamline inference</a></li><li><a class="tocitem" href="../inference/postprocess/">Inference results postprocessing</a></li><li><a class="tocitem" href="../inference/manual/">Manual inference specification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox" checked/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Inference customization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Defining a custom node and rules</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Step-1:-Creating-the-custom-node"><span>Step 1: Creating the custom node</span></a></li><li><a class="tocitem" href="#Step-2:-Defining-rules-for-our-node"><span>Step 2: Defining rules for our node</span></a></li><li><a class="tocitem" href="#Step-3:-Defining-joint-marginals-for-our-node"><span>Step 3: Defining joint marginals for our node</span></a></li><li><a class="tocitem" href="#Step-4:-Defining-the-average-energy-for-our-node"><span>Step 4: Defining the average energy for our node</span></a></li><li><a class="tocitem" href="#Using-our-node-in-a-model"><span>Using our node in a model</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../understanding-why-to-initialize-messages/">Messages initialization</a></li><li><a class="tocitem" href="../debugging/">Debugging</a></li><li><a class="tocitem" href="../delta-node/">Delta node</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/functional-forms/">Built-in functional form constraints</a></li><li><a class="tocitem" href="../../library/model-specification/">Model specification</a></li><li><a class="tocitem" href="../../library/bethe-free-energy/">Bethe Free Energy</a></li><li><a class="tocitem" href="../../library/exported-methods/">Exported methods</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Basic examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/basic_examples/overview/">Overview</a></li><li><a class="tocitem" href="../../examples/basic_examples/Coin Toss Model/">Coin toss model (Beta-Bernoulli)</a></li><li><a class="tocitem" href="../../examples/basic_examples/Bayesian Linear Regression Tutorial/">Bayesian Linear Regression Tutorial</a></li><li><a class="tocitem" href="../../examples/basic_examples/Kalman filtering and smoothing/">Kalman filtering and smoothing</a></li><li><a class="tocitem" href="../../examples/basic_examples/Predicting Bike Rental Demand/">Predicting Bike Rental Demand</a></li><li><a class="tocitem" href="../../examples/basic_examples/Hidden Markov Model/">How to train your Hidden Markov Model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Advanced examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/advanced_examples/overview/">Overview</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Active Inference Mountain car/">Active Inference Mountain car</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Advanced Tutorial/">Advanced Tutorial</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Assessing People Skills/">Assessing People’s Skills</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Chance Constraints/">Chance-Constrained Active Inference</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Conjugate-Computational Variational Message Passing/">Conjugate-Computational Variational Message Passing (CVI)</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Global Parameter Optimisation/">Global Parameter Optimisation</a></li><li><a class="tocitem" href="../../examples/advanced_examples/GP Regression by SSM/">Solve GP regression by SDE</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Infinite Data Stream/">Infinite Data Stream</a></li><li><a class="tocitem" href="../../examples/advanced_examples/Nonlinear Sensor Fusion/">Nonlinear Sensor Fusion</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Problem specific</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/problem_specific/overview/">Overview</a></li><li><a class="tocitem" href="../../examples/problem_specific/Autoregressive Models/">Autoregressive Models</a></li><li><a class="tocitem" href="../../examples/problem_specific/Gamma Mixture/">Gamma Mixture Model</a></li><li><a class="tocitem" href="../../examples/problem_specific/Gaussian Mixture/">Gaussian Mixture</a></li><li><a class="tocitem" href="../../examples/problem_specific/Hierarchical Gaussian Filter/">Hierarchical Gaussian Filter</a></li><li><a class="tocitem" href="../../examples/problem_specific/Invertible Neural Network Tutorial/">Invertible neural networks: a tutorial</a></li><li><a class="tocitem" href="../../examples/problem_specific/Probit Model (EP)/">Probit Model (EP)</a></li><li><a class="tocitem" href="../../examples/problem_specific/RTS vs BIFM Smoothing/">RTS vs BIFM Smoothing</a></li><li><a class="tocitem" href="../../examples/problem_specific/Simple Nonlinear Node/">Simple Nonlinear Node</a></li><li><a class="tocitem" href="../../examples/problem_specific/Universal Mixtures/">Universal Mixtures</a></li></ul></li></ul></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="../../contributing/overview/">Overview</a></li><li><a class="tocitem" href="../../contributing/new-documentation/">Contributing to the documentation</a></li><li><a class="tocitem" href="../../contributing/new-package/">Contributing to the dependencies</a></li><li><a class="tocitem" href="../../contributing/new-example/">Contributing to the examples</a></li><li><a class="tocitem" href="../../contributing/new-release/">Publishing a new release</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User guide</a></li><li><a class="is-disabled">Inference customization</a></li><li class="is-active"><a href>Defining a custom node and rules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Defining a custom node and rules</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/RxInfer.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/RxInfer.jl/blob/main/docs/src/manuals/custom-node.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="create-node"><a class="docs-heading-anchor" href="#create-node">Creating your own custom nodes</a><a id="create-node-1"></a><a class="docs-heading-anchor-permalink" href="#create-node" title="Permalink"></a></h1><p>Welcome to the <code>RxInfer</code> documentation on creating custom factor graph nodes. In <code>RxInfer</code>, factor nodes represent functional relationships between variables, also known as factors. Together, these factors define your probabilistic model. Quite often these factors represent distributions, denoting how a certain parameter affects another. However, other factors are also possible, such as ones specifying linear or non-linear relationships. <code>RxInfer</code> already supports a lot of factor nodes, however, depending on the problem that you are trying to solve, you may need to create a custom node that better fits the specific requirements of your model. This tutorial will guide you through the process of defining a custom node in <code>RxInfer</code>, step by step. By the end of this tutorial, you will be able to create your own custom node and integrate it into your model.</p><p>To create a custom node in <code>RxInfer</code>, 4 steps are required:</p><ol><li>Create your custom node in <code>RxInfer</code> using the <code>@node</code> macro.</li><li>Define the corresponding message passing update rules with the <code>@rule</code> macro. These rules specify how the node processes information in the form of messages, and how it communicates the results to adjacent parts of the model.</li><li>Specify computations for marginal distributions of the relevant variables with the <code>@marginalrule</code> macro.</li><li>Implement the computation of the Free Energy in a node with the <code>@average_energy</code> macro.</li></ol><p>Throughout this tutorial, we will create a node for the <code>Bernoulli</code> distribution. The <code>Bernoulli</code> distribution is a commonly used distribution in statistical modeling that is often used to model a binary outcome, such as a coin flip. By recreating this node, we will be able to demonstrate the process of creating a custom node, from notifying <code>RxInfer</code> of the nodes existence to implementing the required methods. While this tutorial focuses on the <code>Bernoulli</code> distribution, the principles can be applied to creating custom nodes for other distributions as well. So let&#39;s get started!</p><h2 id="Problem-statement"><a class="docs-heading-anchor" href="#Problem-statement">Problem statement</a><a id="Problem-statement-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-statement" title="Permalink"></a></h2><p>Jane wants to determine whether a coin is a fair coin, meaning that is equally likely to land on heads or tails. In order to determine this, she will throw the coin <span>$K=20$</span> times and write down how often it lands on heads and tails. The result of this experiment is a realization of the underlying stochastic process. Jane models the outcome of the experiment <span>$x_k\in\{0,1\}$</span> using the Bernoulli distribution as</p><p class="math-container">\[p(x_k \mid \pi) = \mathrm{Ber}(x_k \mid \pi) = \pi^{x_k} (1-\pi)^{1-x_k},\]</p><p>where <span>$\pi \in[0,1]$</span> denotes the probability that she throws heads, also known as the success probability. Jane also has a prior belief (initial guess) about the value of <span>$\pi$</span> which she models using the Beta distribution as</p><p class="math-container">\[p(\pi) = \mathrm{Beta}(\pi \mid 4, 8).\]</p><p>With this prior belief, the total probabilistic model that she has for this experiment is given by</p><p class="math-container">\[p(x_{1:K}, \pi) = p(\pi) \prod_{k=1}^K p(x_k \mid \pi).\]</p><p>Jane is interested in determining the fairness of the coin. Therefore she aims to infer (calculate) the posterior belief of <span>$\pi$</span>, <span>$p(\pi \mid x_{1:K})$</span>, denoting how <span>$\pi$</span> is distributed after we have seen the data.</p><hr/><h2 id="Step-1:-Creating-the-custom-node"><a class="docs-heading-anchor" href="#Step-1:-Creating-the-custom-node">Step 1: Creating the custom node</a><a id="Step-1:-Creating-the-custom-node-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Creating-the-custom-node" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In this example we will assume that the <code>Bernoulli</code> node and distribution do not yet exist. The <code>RxInfer</code> already defines the node for the <code>Bernoulli</code> distribution from the <code>Distributions.jl</code> package.</p></div></div><p>First things first, let&#39;s import <code>RxInfer</code>:</p><pre><code class="language-julia hljs">using RxInfer</code></pre><p>In order to define a custom node using the <code>@node</code> macro from <code>RxInfer</code>, we need the following three arguments:</p><ol><li>The name of the node. (<code>::Type</code>)</li><li>Whether the node is <code>Deterministic</code> or <code>Stochastic</code>.</li><li>The interfaces of the node and any potential aliases. (<code>::Vector</code>)</li></ol><p>For the name of the node we wish to use <code>MyBernoulli</code> in this tutorial (<code>Bernoulli</code> already exists). However, the corresponding distribution does not yet exist. Therefore we need to specify it first as</p><pre><code class="language-julia hljs"># struct for Bernoulli distribution with success probability π
struct MyBernoulli{T &lt;: Real} &lt;: ContinuousUnivariateDistribution
    π :: T
    new(π :: Real) = 0 ≤ π ≤ 1 ? MyBernoulli(π) : throw(ArgumentError(&quot;π must be between 0 and 1&quot;))
end

# for simplicity, let&#39;s also specify the mean of the distribution
Distributions.mean(d::MyBernoulli) = d.π</code></pre><p>In this case the distribution also has an entry in the struct, however, this is not necessary as long as the name of the distribution is a <code>Type</code>. The custom node created with <code>struct NewNode end</code> would also work fine.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can use regular functions, e.g <code>+</code> as a node type. Their Julia type, however, is written with the <code>typeof(_)</code> specification, e.g. <code>typeof(+)</code></p></div></div><p>For our node we are dealing with a stochastic node, because the node forms a probabilistic relationship. This means that for a given value of <span>$\pi$</span>, we do know the corresponding value of the output, but we do have some belief about this. Deterministic nodes include for example linear and non-linear transformation.</p><p>The interfaces specify what variables are connected to the node. The first argument is its output by convention. The ordering is important for both the model specification as the rule definition. As an example consider the <code>NormalMeanVariance</code> factor node. This factor node has interfaces <code>[out, μ, v]</code> and can be called in the model specification language as <code>x ~ NormalMeanVariance(μ, v)</code>. It is also possible to use aliases for the interfaces, which can be specified in a tuple as you will see below.</p><p>Concluding, we can create the <code>MyBernoulli</code> factor node as</p><pre><code class="language-julia hljs">@node MyBernoulli Stochastic [out, (π, aliases = [p])]</code></pre><p>Cool! Step 1 is done, we have created a custom node.</p><hr/><h2 id="Step-2:-Defining-rules-for-our-node"><a class="docs-heading-anchor" href="#Step-2:-Defining-rules-for-our-node">Step 2: Defining rules for our node</a><a id="Step-2:-Defining-rules-for-our-node-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Defining-rules-for-our-node" title="Permalink"></a></h2><p>In order for <code>RxInfer</code> to perform probabilistic inference and compute posterior distributions, such as <span>$p(\pi\mid x_{1:K})$</span>, we need to tell it how to perform inference locally around our node. This localization is what makes <code>RxInfer</code> achieve high performance. In our message passing-based paradigm, we need to describe how the node processes incoming information in the form of messages (or marginals). Here we will highlight two different message passing strategies: sum-product message passing and variational message passing.</p><h3 id="Sum-product-message-passing-update-rules"><a class="docs-heading-anchor" href="#Sum-product-message-passing-update-rules">Sum-product message passing update rules</a><a id="Sum-product-message-passing-update-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Sum-product-message-passing-update-rules" title="Permalink"></a></h3><p>In sum-product message passing we compute outgoing messages to our node as</p><p class="math-container">\[\vec{\mu}(x) \propto \int \mathrm{Ber}(x\mid \pi) \vec{\mu}(\pi) \mathrm{d}x\]</p><p class="math-container">\[\overleftarrow{\mu}(\pi) \propto \sum_{x \in \{0,1\}} \mathrm{Ber}(x\mid \pi) \overleftarrow{\mu}(x)\]</p><p>This integral does not always have nice tractable solutions. However, for some forms of the incoming messages, it does yield a tractable solution.</p><p>For the case of a <code>Beta</code> message coming into our node, the outgoing message will be the predictive posterior of the <code>Bernoulli</code> distribution with a <code>Beta</code> prior. Here we obtain <span>$\pi = \frac{\alpha}{\alpha + \beta}$</span>, which coincides with the mean of the <code>Beta</code> distribution. Hence, we can write down the first update rule using the <code>@rule</code> macro as</p><pre><code class="language-julia hljs">@rule MyBernoulli(:out, Marginalisation) (m_π :: Beta,) = MyBernoulli(mean(m_π))</code></pre><p>Here, <code>:out</code> refers to the interface of the outgoing message. The second argument denotes the incoming messages (which can be typed) as a tuple. Therefore make sure that it has a trailing <code>,</code> when there is a single message coming in. <code>m_π</code> is shorthand for &quot;the incoming message on interface <code>π</code>&quot;. As we will see later, the structured approximation update rule for incoming message from <code>π</code> will have <code>q_π</code> as parameter.</p><p>The second rule is also straightforward; if <code>π</code> is a <code>PointMass</code> and therefore fixed, the outgoing message will be <code>MyBernoulli(π)</code>:</p><pre><code class="language-julia hljs">@rule MyBernoulli(:out, Marginalisation) (m_π :: PointMass,) = MyBernoulli(mean(m_π))</code></pre><p>Continuing with the sum-product update rules, we now have to define the update rules towards the <code>π</code> interface. We can only do exact inference if the incoming message is known, which in the case of the <code>Bernoulli</code> distribution, means that the <code>out</code> message is a <code>PointMass</code> distribution that is either <code>0</code> or <code>1</code>. The updated Beta distribution for <code>π</code> will be:</p><p class="math-container">\[\overleftarrow{\mu}(π) \propto \mathrm{Beta}(1 + x, 2 - x)\]</p><p>Which gives us the following update rule:</p><pre><code class="language-julia hljs">@rule MyBernoulli(:π, Marginalisation) (m_out :: PointMass,) = begin
    p = mean(m_out)
    Beta(one(p) + p, 2one(p) - p)
end</code></pre><h3 id="Variational-message-passing-update-rules"><a class="docs-heading-anchor" href="#Variational-message-passing-update-rules">Variational message passing update rules</a><a id="Variational-message-passing-update-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Variational-message-passing-update-rules" title="Permalink"></a></h3><p>We will now cover our second set of update rules. The sum-product messages are not always tractable and therefore we may need to resort to approximations. Here we highlight the variational approximation. In variational message passing we compute outgoing messages to our node as</p><p class="math-container">\[\vec{\nu}(x) \propto \exp \int q(\pi) \ln \mathrm{Ber}(x\mid \pi) \mathrm{d}x\]</p><p class="math-container">\[\overleftarrow{\nu}(\pi) \propto \exp \sum_{x \in \{0,1\}} q(x) \ln \mathrm{Ber}(x\mid \pi)\]</p><p>These messages depend on the marginals on the adjacent edges and not on the incoming messages as was the case with sum-product message passing. Update rules that operate on the marginals instead of the incoming messages are specified with the <code>q_{interface}</code> argument names. With these update rules, we can often support a wider family of distributions. Below we directly give the variational update rules. Deriving them yourself will be a nice challenge.</p><pre><code class="language-julia hljs">#rules towards out
@rule MyBernoulli(:out, Marginalisation) (q_π :: PointMass,) = MyBernoulli(mean(q_π))

@rule Bernoulli(:out, Marginalisation) (q_π::Any,) = begin
    rho_1 = mean(log, q_π)          # E[ln(x)]
    rho_2 = mean(mirrorlog, q_π)    # E[log(1-x)]
    m = max(rho_1, rho_2)
    tmp = exp(rho_1 - m)
    p = clamp(tmp / (tmp + exp(rho_2 - m)), tiny, one(m))
    return Bernoulli(p)
end

#rules towards π
@rule MyBernoulli(:π, Marginalisation) (q_out :: Any,) = begin
    p = mean(q_out)
    return Beta(one(p) + p, 2one(p) - p)
end</code></pre><div class="admonition is-category-node"><header class="admonition-header">Node</header><div class="admonition-body"><p>Typically, the type of the variational distributions <code>q_</code> does not matter in the real computations, but only their statistics, e.g <code>mean</code> or <code>var</code>. Thus, in this case, we may safely use <code>::Any</code>.</p></div></div><p>In the example that we will show later on, we solely use sum-product message passing. Variational message passing requires us to set the local constraints in our model, something which is out of scope of this tutorial.</p><hr/><h2 id="Step-3:-Defining-joint-marginals-for-our-node"><a class="docs-heading-anchor" href="#Step-3:-Defining-joint-marginals-for-our-node">Step 3: Defining joint marginals for our node</a><a id="Step-3:-Defining-joint-marginals-for-our-node-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Defining-joint-marginals-for-our-node" title="Permalink"></a></h2><p>The entire probabilistic model can be scored using the Bethe free energy, which bounds the log-evidence for acyclic graphs. This Bethe free energy consists out of the sum of node-local entropies, negative node-local average energies and edge specific entropies. Formally we can denote this by</p><p class="math-container">\[F[q,f] = - \sum_{a\in\mathcal{V}} \mathrm{H}[q_a(s_a)] - \sum_{a\in\mathcal{V}}\mathrm{E}_{q_a(s_a)}[\ln f_a(s_a)] + \sum_{i\in\mathcal{E}}\mathrm{H}[q_i(s_i)]\]</p><p>Here we call <span>$q_a(s_a)$</span> the joint marginals around a node and <span>$-\mathrm{E}_{q_a(s_a)}[\ln f_a(s_a)]$</span> we term the average energy.</p><p>In order to be able to compute the Bethe free energy, we need to first describe how to compute <span>$q_a(s_a)$</span>, defined in our case as </p><p class="math-container">\[q(x_k, \pi) = \vec{\mu}(\pi) \overleftarrow{\mu}(x_k) \mathrm{Ber}(x_k \mid \pi)\]</p><p>To calculate the updated posterior marginal for our custom distribution, we need to return joint posterior marginals for the interfaces of our node. In our case, the posterior marginal for the observation is still the same <code>PointMass</code> distribution. However, to calculate the posterior marginal over <code>π</code>, we use <code>RxInfer</code>&#39;s built-in <code>prod</code> functionality to multiply the <code>Beta</code> prior with the <code>Beta</code> likelihood. This gives us the updated posterior distribution, which is also a <code>Beta</code> distribution. We use <code>ProdAnalytical()</code> parameter to ensure that we multiply the two distributions analytically. This is done as follows:</p><pre><code class="language-julia hljs">@marginalrule MyBernoulli(:out_π) (m_out::PointMass, m_π::Beta) = begin
    r = mean(m_out)
    p = prod(ProdAnalytical(), Beta(one(r) + r, 2one(r) - r), m_π)
    return (out = m_out, p = p)
end</code></pre><p>In this code <code>:out_π</code> describes the arguments of the joint marginal distribution. The second argument contains the incoming messages. Here we know from the model specification that we observe <code>out</code> and therefore this has to be a <code>PointMass</code>. Because it is a <code>PointMass</code>, the joint marginal automatically factorizes as <span>$q(x_k, \pi) = q(x_k)q(\pi)$</span>. These are the distributions that we return in a form of the <code>NamedTuple</code>. <code>NamedTuple</code> is used only in cases where we know that the joint marginal factorizes further, but typically it should be a full distribution. For computing <span>$q(\pi)$</span> we need to compute the product <span>$\vec{\mu}(\pi)\overleftarrow{\mu}(\pi)$</span>. We already know how <span>$\overleftarrow{\mu}(\pi)$</span> looks like from the previous step, so we can just use the <code>prod</code> function.</p><hr/><h2 id="Step-4:-Defining-the-average-energy-for-our-node"><a class="docs-heading-anchor" href="#Step-4:-Defining-the-average-energy-for-our-node">Step 4: Defining the average energy for our node</a><a id="Step-4:-Defining-the-average-energy-for-our-node-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Defining-the-average-energy-for-our-node" title="Permalink"></a></h2><p>To complete the computation of the Bethe free energy, we also need to compute the average energy term. The average energy in our <code>MyBernoulli</code> example can be computed as <span>$-\mathrm{E}_{q(x_k, \pi)}[\ln p(x_k \mid \pi)]$</span>, however, because we know that we observe <span>$x_k$</span> and therefore <span>$q(x_k, \pi)$</span> factorizes, we can instead compute <span>$\begin{aligned} -\mathrm{E}_{q(x_k)q(\pi)}[\ln p(x_k \mid \pi)] &amp;= -\mathrm{E}_{q(x_k)q(\pi)} [\ln (\pi^{x_k} (1-\pi)^{1 - x_k})] \\
&amp;= -\mathrm{E}_{q(x_k)q(\pi)} [x_k \ln(\pi) + (1-x_k) \ln(1-\pi)] \\
&amp;= -\mathrm{E}_{q(x_k)}[x_k] \mathrm{E}_{q(\pi)} [\ln(\pi)] - (1-\mathrm{E}_{q(x_k)}[x_k]) \mathrm{E}_{q(\pi)}[\ln(1-\pi)] \end{aligned}$</span></p><p>Which is what we implemented below. Note that <code>mean(mirrorlog, q(x))</code> is equal to <span>$\mathrm{E}_{q(x)}[1-\log{x}]$</span>.</p><pre><code class="language-julia hljs">@average_energy Bernoulli (q_out::Any, q_π::Any) = -mean(q_out) * mean(log, q_π) - (1.0 - mean(q_out)) * mean(mirrorlog, q_π)</code></pre><p>In the case that the interfaces do not factorize, we would get something like <code>@average_energy MyBernoulli (q_out_π) ...</code>.</p><h2 id="Using-our-node-in-a-model"><a class="docs-heading-anchor" href="#Using-our-node-in-a-model">Using our node in a model</a><a id="Using-our-node-in-a-model-1"></a><a class="docs-heading-anchor-permalink" href="#Using-our-node-in-a-model" title="Permalink"></a></h2><p>With all the necessary functions defined, we can proceed to test our custom node in an experiment. For this experiment, we will generate a dataset from a Bernoulli distribution with a fixed success probability of 0.75. Next, we will define a probabilistic model that has a <code>Beta</code> prior and a <code>MyBernoulli</code> likelihood. The <code>Beta</code> prior will be used to model our prior belief about the probability of success. The <code>MyBernoulli</code> likelihood will be used to model the generative process of the observed data. We start by generating the dataset:</p><pre><code class="language-julia hljs">using Random

rng = MersenneTwister(42)
n = 500
π_real = 0.75
distribution = Bernoulli(π_real)

dataset = float.(rand(rng, distribution, n))</code></pre><p>Next, we define our model. Note that we use the <code>MyBernoulli</code> node in the model. The model consists of a single latent variable <code>π</code>, which has a <code>Beta</code> prior and is the parameter of the <code>MyBernoulli</code> likelihood. The <code>MyBernoulli</code> node takes the value of <code>π</code> as its parameter and returns a binary observation. We set the hyperparameters of the <code>Beta</code> prior to be 4 and 8, respectively, which correspond to a distribution slightly biased towards higher values of <code>π</code>. The model is defined as follows:</p><pre><code class="language-julia hljs">@model function coin_model_mybernoulli(n)

    # `datavar` creates data &#39;inputs&#39; in our model
    y = datavar(Float64, n)

    # We endow θ parameter of our model with some prior
    π ~ Beta(4.0, 8.0)

    # We assume that outcome of each coin flip is governed by the MyBernoulli distribution
    for i in 1:n
        y[i] ~ MyBernoulli(π)
    end

end</code></pre><p>Finally, we can run inference with this model and the generated dataset:</p><pre><code class="language-julia hljs">result_mybernoulli = infer(
    model = coin_model_mybernoulli(length(dataset)),
    data  = (y = dataset, ),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inference results:
  Posteriors       | available for (π)
</code></pre><p>We have now completed our experiment and obtained the posterior marginal distribution for p through inference. To evaluate the performance of our inference, we can compare the estimated posterior to the true value. In our experiment, the true value for p is 0.75, and we can see that the estimated posterior has a mean of approximately 0.713, which shows that our custom node was able to successfully pass messages towards the <code>π</code> variable in order to learn the true value of the parameter.</p><pre><code class="language-julia hljs">using Plots

rθ = range(0, 1, length = 1000)

p = plot(title = &quot;Inference results&quot;)

plot!(rθ, (x) -&gt; pdf(result_mybernoulli.posteriors[:π], x), fillalpha=0.3, fillrange = 0, label=&quot;p(π|x)&quot;, c=3)
vline!([π_real], label=&quot;Real π&quot;)</code></pre><img src="c457da72.svg" alt="Example block output"/><p>As a sanity check, we can create the same model with the <code>RxInfer</code> built-in node <code>Bernoulli</code> and compare the resulting posterior distribution with the one obtained using our custom <code>MyBernoulli</code> node. This will give us confidence that our custom node is working correctly. We use the <code>Bernoulli</code> node with the same <code>Beta</code> prior and the observed data, and then run inference. We can compare the two posterior distributions and observe that they are exactly the same, which indicates that our custom node is performing as expected.</p><pre><code class="language-julia hljs">@model function coin_model(n)

    y = datavar(Float64, n)
    p ~ Beta(4.0, 8.0)

    for i in 1:n
        y[i] ~ Bernoulli(p)
    end

end

result_bernoulli = infer(
    model = coin_model(length(dataset)),
    data  = (y = dataset, ),
)

if !(result_bernoulli.posteriors[:p] == result_mybernoulli.posteriors[:π])
    error(&quot;Results are not identical&quot;)
else
    println(&quot;Results are identical 🎉🎉🎉&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Results are identical 🎉🎉🎉</code></pre><p>Congratulations! You have successfully implemented your own custom node in <code>RxInfer</code>. We went through the definition of a node to the implementation of the update rules and marginal posterior calculations. Finally we tested our custom node in a model and checked if we implemented everything correctly.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../inference/manual/">« Manual inference specification</a><a class="docs-footer-nextpage" href="../understanding-why-to-initialize-messages/">Messages initialization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 18 March 2024 15:32">Monday 18 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
