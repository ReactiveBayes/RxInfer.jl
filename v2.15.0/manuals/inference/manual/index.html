<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual inference specification · RxInfer.jl</title><meta name="title" content="Manual inference specification · RxInfer.jl"/><meta property="og:title" content="Manual inference specification · RxInfer.jl"/><meta property="twitter:title" content="Manual inference specification · RxInfer.jl"/><meta name="description" content="Documentation for RxInfer.jl."/><meta property="og:description" content="Documentation for RxInfer.jl."/><meta property="twitter:description" content="Documentation for RxInfer.jl."/><meta property="og:url" content="https://biaslab.github.io/RxInfer.jl/manuals/inference/manual/"/><meta property="twitter:url" content="https://biaslab.github.io/RxInfer.jl/manuals/inference/manual/"/><link rel="canonical" href="https://biaslab.github.io/RxInfer.jl/manuals/inference/manual/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/theme.css" rel="stylesheet" type="text/css"/><link href="../../../assets/header.css" rel="stylesheet" type="text/css"/><script src="../../../assets/header.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img class="docs-light-only" src="../../../assets/logo.svg" alt="RxInfer.jl logo"/><img class="docs-dark-only" src="../../../assets/logo-dark.svg" alt="RxInfer.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">RxInfer.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../../getting-started/">Getting started</a></li><li><a class="tocitem" href="../../comparison/">RxInfer.jl vs. Others</a></li><li><a class="tocitem" href="../../model-specification/">Model specification</a></li><li><a class="tocitem" href="../../constraints-specification/">Constraints specification</a></li><li><a class="tocitem" href="../../meta-specification/">Meta specification</a></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox" checked/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Inference specification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../inference/">Static dataset</a></li><li><a class="tocitem" href="../rxinference/">Real-time dataset / reactive inference</a></li><li><a class="tocitem" href="../postprocess/">Inference results postprocessing</a></li><li class="is-active"><a class="tocitem" href>Manual inference specification</a><ul class="internal"><li><a class="tocitem" href="#user-guide-manual-inference-model-creation"><span>Model creation</span></a></li><li><a class="tocitem" href="#user-guide-manual-inference-marginal-updates"><span>Posterior marginal updates</span></a></li><li><a class="tocitem" href="#user-guide-manual-inference-observations"><span>Feeding observations</span></a></li><li><a class="tocitem" href="#user-guide-manual-inference-vmp"><span>Variational Message Passing</span></a></li><li><a class="tocitem" href="#user-guide-manual-inference-vmp-bfe"><span>Computing Bethe Free Energy</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Inference customization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../custom-node/">Defining a custom node and rules</a></li></ul></li><li><a class="tocitem" href="../../debugging/">Debugging</a></li><li><a class="tocitem" href="../../delta-node/">Delta node</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../../library/functional-forms/">Built-in functional form constraints</a></li><li><a class="tocitem" href="../../../library/model-specification/">Model specification</a></li><li><a class="tocitem" href="../../../library/bethe-free-energy/">Bethe Free Energy</a></li><li><a class="tocitem" href="../../../library/exported-methods/">Exported methods</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../../examples/overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Basic examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../examples/basic_examples/overview/">Overview</a></li><li><a class="tocitem" href="../../../examples/basic_examples/Coin Toss Model/">Coin toss model (Beta-Bernoulli)</a></li><li><a class="tocitem" href="../../../examples/basic_examples/Bayesian Linear Regression Tutorial/">Bayesian Linear Regression Tutorial</a></li><li><a class="tocitem" href="../../../examples/basic_examples/Kalman filtering and smoothing/">Kalman filtering and smoothing</a></li><li><a class="tocitem" href="../../../examples/basic_examples/Predicting Bike Rental Demand/">Predicting Bike Rental Demand</a></li><li><a class="tocitem" href="../../../examples/basic_examples/Hidden Markov Model/">How to train your Hidden Markov Model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Advanced examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../examples/advanced_examples/overview/">Overview</a></li><li><a class="tocitem" href="../../../examples/advanced_examples/Active Inference Mountain car/">Active Inference Mountain car</a></li><li><a class="tocitem" href="../../../examples/advanced_examples/Advanced Tutorial/">Advanced Tutorial</a></li><li><a class="tocitem" href="../../../examples/advanced_examples/Assessing People Skills/">Assessing People’s Skills</a></li><li><a class="tocitem" href="../../../examples/advanced_examples/Chance Constraints/">Chance-Constrained Active Inference</a></li><li><a class="tocitem" href="../../../examples/advanced_examples/Conjugate-Computational Variational Message Passing/">Conjugate-Computational Variational Message Passing (CVI)</a></li><li><a class="tocitem" href="../../../examples/advanced_examples/Global Parameter Optimisation/">Global Parameter Optimisation</a></li><li><a class="tocitem" href="../../../examples/advanced_examples/GP Regression by SSM/">Solve GP regression by SDE</a></li><li><a class="tocitem" href="../../../examples/advanced_examples/Infinite Data Stream/">Infinite Data Stream</a></li><li><a class="tocitem" href="../../../examples/advanced_examples/Nonlinear Sensor Fusion/">Nonlinear Sensor Fusion</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Problem specific</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../examples/problem_specific/overview/">Overview</a></li><li><a class="tocitem" href="../../../examples/problem_specific/Autoregressive Models/">Autoregressive Models</a></li><li><a class="tocitem" href="../../../examples/problem_specific/Gamma Mixture/">Gamma Mixture Model</a></li><li><a class="tocitem" href="../../../examples/problem_specific/Gaussian Mixture/">Gaussian Mixture</a></li><li><a class="tocitem" href="../../../examples/problem_specific/Hierarchical Gaussian Filter/">Hierarchical Gaussian Filter</a></li><li><a class="tocitem" href="../../../examples/problem_specific/Invertible Neural Network Tutorial/">Invertible neural networks: a tutorial</a></li><li><a class="tocitem" href="../../../examples/problem_specific/Probit Model (EP)/">Probit Model (EP)</a></li><li><a class="tocitem" href="../../../examples/problem_specific/RTS vs BIFM Smoothing/">RTS vs BIFM Smoothing</a></li><li><a class="tocitem" href="../../../examples/problem_specific/Simple Nonlinear Node/">Simple Nonlinear Node</a></li><li><a class="tocitem" href="../../../examples/problem_specific/Universal Mixtures/">Universal Mixtures</a></li></ul></li></ul></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="../../../contributing/overview/">Overview</a></li><li><a class="tocitem" href="../../../contributing/new-documentation/">Contributing to the documentation</a></li><li><a class="tocitem" href="../../../contributing/new-package/">Contributing to the dependencies</a></li><li><a class="tocitem" href="../../../contributing/new-example/">Contributing to the examples</a></li><li><a class="tocitem" href="../../../contributing/new-release/">Publishing a new release</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User guide</a></li><li><a class="is-disabled">Inference specification</a></li><li class="is-active"><a href>Manual inference specification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual inference specification</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/biaslab/RxInfer.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/biaslab/RxInfer.jl/blob/main/docs/src/manuals/inference/manual.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="user-guide-manual-inference"><a class="docs-heading-anchor" href="#user-guide-manual-inference">Manual inference</a><a id="user-guide-manual-inference-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-manual-inference" title="Permalink"></a></h1><p>For advanced use cases it is advised to use manual inference specification. </p><p>Manual inference specification with <code>RxInfer</code> usually consists of the same simple building blocks and designed in such a way to support both static and real-time infinite datasets:</p><ol><li>Create a model with <code>@model</code> macro and get a references to random variables and data inputs</li><li>Subscribe to random variable posterior marginal updates </li><li>Subscribe to Bethe Free Energy updates (optional)</li><li>Feed model with observations </li><li>Unsubscribe from posterior marginal updates (optional)</li></ol><p>It is worth to note that Step 5 is optional and in case where observations come from an infinite real-time data stream (e.g. from an external source or the internet) it may be justified to never unsubscribe and perform real-time Bayesian inference in a reactive manner as soon as data arrives.</p><h2 id="user-guide-manual-inference-model-creation"><a class="docs-heading-anchor" href="#user-guide-manual-inference-model-creation">Model creation</a><a id="user-guide-manual-inference-model-creation-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-manual-inference-model-creation" title="Permalink"></a></h2><p>During model specification stage user decides on variables of interest in a model and returns (optionally) them using a <code>return ...</code> statement. As an example consider that we have a simple hierarchical model in which the mean of a Normal distribution is represented by another Normal distribution whose mean is modelled by another Normal distribution.</p><pre><code class="language-julia hljs">using RxInfer, Distributions, Random

@model function my_model()
    m2 ~ NormalMeanVariance(0.0, 1.0)
    m1 ~ NormalMeanVariance(m2, 1.0)

    y = datavar(Float64)
    y ~ NormalMeanVariance(m1, 1.0)

    # Return variables of interests, optional
    return m1, y
end</code></pre><p>And later on we may create our model with the <a href="../../../library/model-specification/#RxInfer.create_model"><code>create_model</code></a> function and obtain references for variables of interests:</p><pre><code class="language-julia hljs">model, (m1, y) = create_model(my_model())</code></pre><p>Alternatively, it is possible to query any variable using squared brackets on <code>model</code> object:</p><pre><code class="language-julia hljs">model[:m1] # m1
model[:y]  # y</code></pre><p><code>@model</code> macro also return a reference for a factor graph as its first return value. Factor graph object (named <code>model</code> in previous example) contains all information about all factor nodes in a model as well as random variables and data inputs.</p><h2 id="user-guide-manual-inference-marginal-updates"><a class="docs-heading-anchor" href="#user-guide-manual-inference-marginal-updates">Posterior marginal updates</a><a id="user-guide-manual-inference-marginal-updates-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-manual-inference-marginal-updates" title="Permalink"></a></h2><p>The <code>RxInfer</code> inference engine has a reactive API and operates in terms of Observables and Actors. For detailed information about these concepts we refer to <a href="https://biaslab.github.io/Rocket.jl/stable/observables/about/">Rocket.jl documentation</a>.</p><p>We use <code>getmarginal</code> function from <code>ReactiveMP</code> to get a posterior marginal updates observable:</p><pre><code class="language-julia hljs">m1_posterior_updates = getmarginal(m1)</code></pre><p>After that we can subscribe on new updates and perform some actions based on new values:</p><pre><code class="language-julia hljs">m1_posterior_subscription = subscribe!(m1_posterior_updates, (new_posterior) -&gt; begin
    println(&quot;New posterior for m1: &quot;, new_posterior)
end)</code></pre><p>Sometimes it is useful to return an array of random variables from model specification, in this case we may use <code>getmarginals()</code> function that transform an array of observables to an observable of arrays.</p><pre><code class="language-julia hljs">@model function my_model()
    ...
    m_n = randomvar(n)
    ...
    return m_n, ...
end

model, (m_n, ...) = create_model(my_model())

m_n_updates = getmarginals(m_n)</code></pre><h2 id="user-guide-manual-inference-observations"><a class="docs-heading-anchor" href="#user-guide-manual-inference-observations">Feeding observations</a><a id="user-guide-manual-inference-observations-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-manual-inference-observations" title="Permalink"></a></h2><p>By default (without any extra factorisation constraints) model specification implies Belief Propagation message passing update rules. In case of BP algorithm <code>RxInfer</code> package computes an exact Bayesian posteriors with a single message passing iteration. To enforce Belief Propagation message passing update rule for some specific factor node user may use <code>where { q = FullFactorisation() }</code> option. Read more in <a href="../../model-specification/#user-guide-model-specification">Model Specification</a> section. To perform a message passing iteration we need to pass some data to all our data inputs that were created with <a href="../../model-specification/#user-guide-model-specification-data-variables"><code>datavar</code> function</a> during model specification.</p><p>To feed an observation for a specific data input we use <code>update!</code> function:</p><pre><code class="language-julia hljs">update!(y, 0.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">New posterior for m1: Marginal(NormalWeightedMeanPrecision{Float64}(xi=0.0, w=1.5))</code></pre><p>As you can see after we passed a single value to our data input we got a posterior marginal update from our subscription and printed it with <code>println</code> function. In case of BP if observations do not change it should not affect posterior marginal results:</p><pre><code class="language-julia hljs">update!(y, 0.0) # Observation didn&#39;t change, should result in the same posterior</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">New posterior for m1: Marginal(NormalWeightedMeanPrecision{Float64}(xi=0.0, w=1.5))</code></pre><p>If <code>y</code> is an array of data inputs it is possible to pass an array of observation to <code>update!</code> function:</p><pre><code class="language-julia hljs">for i in 1:length(data)
    update!(y[i], data[i])
end
# is an equivalent of
update!(y, data)</code></pre><h2 id="user-guide-manual-inference-vmp"><a class="docs-heading-anchor" href="#user-guide-manual-inference-vmp">Variational Message Passing</a><a id="user-guide-manual-inference-vmp-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-manual-inference-vmp" title="Permalink"></a></h2><p>Variational message passing (VMP) algorithms are generated much in the same way as the belief propagation algorithm we saw in the previous section. There is a major difference though: for VMP algorithm generation we need to define the factorization properties of our approximate distribution. A common approach is to assume that all random variables of the model factorize with respect to each other. This is known as the mean field assumption. In <code>RxInfer</code>, the specification of such factorization properties is defined during model specification stage using the <code>where { q = ... }</code> syntax or with the <code>@constraints</code> macro (see <a href="../../constraints-specification/#user-guide-constraints-specification">Constraints specification</a> section for more info about the <code>@constraints</code> macro). Let&#39;s take a look at a simple example to see how it is used. In this model we want to learn the mean and precision of a Normal distribution, where the former is modelled with a Normal distribution and the latter with a Gamma.</p><pre><code class="language-julia hljs">using RxInfer, Distributions, Random</code></pre><pre><code class="language-julia hljs">real_mean      = -4.0
real_precision = 0.2
rng            = MersenneTwister(1234)

n    = 100
data = rand(rng, Normal(real_mean, sqrt(inv(real_precision))), n)</code></pre><pre><code class="language-julia hljs">@model function normal_estimation(n)
    m ~ NormalMeanVariance(0.0, 10.0)
    w ~ Gamma(0.1, 10.0)

    y = datavar(Float64, n)

    for i in 1:n
        y[i] ~ NormalMeanPrecision(m, w) where { q = MeanField() }
    end

    return m, w, y
end</code></pre><p>We create our model as usual, however in order to start VMP inference procedure we need to set initial posterior marginals for all random variables in the model:</p><pre><code class="language-julia hljs">model, (m, w, y) = create_model(normal_estimation(n))

# We use vague initial marginals
setmarginal!(m, vague(NormalMeanVariance))
setmarginal!(w, vague(Gamma))</code></pre><p>To perform a single VMP iteration it is enough to feed all data inputs with some values. To perform multiple VMP iterations we should feed our all data inputs with the same values multiple times:</p><pre><code class="language-julia hljs">m_marginals = []
w_marginals = []

subscriptions = subscribe!([
    (getmarginal(m), (marginal) -&gt; push!(m_marginals, marginal)),
    (getmarginal(w), (marginal) -&gt; push!(w_marginals, marginal)),
])

vmp_iterations = 10

for _ in 1:vmp_iterations
    update!(y, data)
end

unsubscribe!(subscriptions)</code></pre><p>As we process more VMP iterations, our beliefs about the possible values of <code>m</code> and <code>w</code> converge and become more confident.</p><pre><code class="language-julia hljs">using Plots

p1    = plot(title = &quot;&#39;Mean&#39; posterior marginals&quot;)
grid1 = -6.0:0.01:4.0

for iter in [ 1, 2, 10 ]

    estimated = Normal(mean(m_marginals[iter]), std(m_marginals[iter]))
    e_pdf     = (x) -&gt; pdf(estimated, x)

    plot!(p1, grid1, e_pdf, fill = true, opacity = 0.3, label = &quot;Estimated mean after $iter VMP iterations&quot;)

end

plot!(p1, [ real_mean ], seriestype = :vline, label = &quot;Real mean&quot;, color = :red4, opacity = 0.7)</code></pre><img src="28a97407.svg" alt="Example block output"/><pre><code class="language-julia hljs">p2    = plot(title = &quot;&#39;Precision&#39; posterior marginals&quot;)
grid2 = 0.01:0.001:0.35

for iter in [ 2, 3, 10 ]

    estimated = Gamma(shape(w_marginals[iter]), scale(w_marginals[iter]))
    e_pdf     = (x) -&gt; pdf(estimated, x)

    plot!(p2, grid2, e_pdf, fill = true, opacity = 0.3, label = &quot;Estimated precision after $iter VMP iterations&quot;)

end

plot!(p2, [ real_precision ], seriestype = :vline, label = &quot;Real precision&quot;, color = :red4, opacity = 0.7)</code></pre><img src="1139e325.svg" alt="Example block output"/><h2 id="user-guide-manual-inference-vmp-bfe"><a class="docs-heading-anchor" href="#user-guide-manual-inference-vmp-bfe">Computing Bethe Free Energy</a><a id="user-guide-manual-inference-vmp-bfe-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-manual-inference-vmp-bfe" title="Permalink"></a></h2><p>VMP inference boils down to finding the member of a family of tractable probability distributions that is closest in KL divergence to an intractable posterior distribution. This is achieved by minimizing a quantity known as Variational Free Energy. <code>RxInfer</code> uses Bethe Free Energy approximation to the real Variational Free Energy. Free energy is particularly useful to test for convergence of the VMP iterative procedure.</p><p>The <code>RxInfer</code> package exports <code>score</code> function for an observable of free energy values:</p><pre><code class="language-julia hljs">fe_observable = score(model, BetheFreeEnergy())</code></pre><pre><code class="language-julia hljs"># Reset posterior marginals for `m` and `w`
setmarginal!(m, vague(NormalMeanVariance))
setmarginal!(w, vague(Gamma))

fe_values = []

fe_subscription = subscribe!(fe_observable, (v) -&gt; push!(fe_values, v))

vmp_iterations = 10

for _ in 1:vmp_iterations
    update!(y, data)
end

unsubscribe!(fe_subscription)</code></pre><pre><code class="language-julia hljs">plot(fe_values, label = &quot;Bethe Free Energy&quot;, xlabel = &quot;Iteration #&quot;)</code></pre><img src="02a3c4a6.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../postprocess/">« Inference results postprocessing</a><a class="docs-footer-nextpage" href="../../custom-node/">Defining a custom node and rules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.0 on <span class="colophon-date" title="Wednesday 29 November 2023 17:37">Wednesday 29 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
