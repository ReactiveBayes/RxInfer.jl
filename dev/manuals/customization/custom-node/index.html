<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Defining a custom node and rules ¬∑ RxInfer.jl</title><meta name="title" content="Defining a custom node and rules ¬∑ RxInfer.jl"/><meta property="og:title" content="Defining a custom node and rules ¬∑ RxInfer.jl"/><meta property="twitter:title" content="Defining a custom node and rules ¬∑ RxInfer.jl"/><meta name="description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="og:description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="twitter:description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="og:url" content="https://reactivebayes.github.io/RxInfer.jl/manuals/customization/custom-node/"/><meta property="twitter:url" content="https://reactivebayes.github.io/RxInfer.jl/manuals/customization/custom-node/"/><link rel="canonical" href="https://reactivebayes.github.io/RxInfer.jl/manuals/customization/custom-node/"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-X4PH160GMF"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-X4PH160GMF', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/theme.css" rel="stylesheet" type="text/css"/><link href="../../../assets/header.css" rel="stylesheet" type="text/css"/><script src="../../../assets/header.js"></script><script src="../../../assets/chat.js"></script><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/><meta name="keywords" content="Julia, Bayesian inference, factor graph, message passing, probabilistic programming, reactive programming, RxInfer">
<link rel="sitemap" type="application/xml" title="Sitemap" href="https://reactivebayes.github.io/RxInfer.jl/stable/sitemap.xml"></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img class="docs-light-only" src="../../../assets/logo.svg" alt="RxInfer.jl logo"/><img class="docs-dark-only" src="../../../assets/logo-dark.svg" alt="RxInfer.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">RxInfer.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../../getting-started/">Getting started</a></li><li><a class="tocitem" href="../../comparison/">RxInfer.jl vs. Others</a></li><li><a class="tocitem" href="../../model-specification/">Model specification</a></li><li><a class="tocitem" href="../../constraints-specification/">Constraints specification</a></li><li><a class="tocitem" href="../../meta-specification/">Meta specification</a></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Inference specification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inference/overview/">Overview</a></li><li><a class="tocitem" href="../../inference/static/">Static inference</a></li><li><a class="tocitem" href="../../inference/streamlined/">Streamline inference</a></li><li><a class="tocitem" href="../../inference/initialization/">Initialization</a></li><li><a class="tocitem" href="../../inference/autoupdates/">Auto-updates</a></li><li><a class="tocitem" href="../../inference/delta-node/">Deterministic nodes</a></li><li><a class="tocitem" href="../../inference/nonconjugate/">Non-conjugate inference</a></li><li><a class="tocitem" href="../../inference/undefinedrules/">Undefined message update rules</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox" checked/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Inference customization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Defining a custom node and rules</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Step-1:-Creating-the-custom-node"><span>Step 1: Creating the custom node</span></a></li><li><a class="tocitem" href="#Step-2:-Defining-rules-for-our-node"><span>Step 2: Defining rules for our node</span></a></li><li><a class="tocitem" href="#Step-3:-Defining-joint-marginals-for-our-node"><span>Step 3: Defining joint marginals for our node</span></a></li><li><a class="tocitem" href="#Step-4:-Defining-the-average-energy-for-our-node"><span>Step 4: Defining the average energy for our node</span></a></li><li><a class="tocitem" href="#Using-our-node-in-a-model"><span>Using our node in a model</span></a></li><li class="toplevel"><a class="tocitem" href="#custom-node-experimental"><span>Custom node experimental functionality</span></a></li><li><a class="tocitem" href="#inference-ruleswithnode"><span>Rules that require a reference to a node object</span></a></li></ul></li><li><a class="tocitem" href="../postprocess/">Inference results postprocessing</a></li></ul></li><li><a class="tocitem" href="../../debugging/">Debugging</a></li><li><a class="tocitem" href="../../session_summary/">Session summary</a></li><li><a class="tocitem" href="../../telemetry/">Sharing sessions &amp; telemetry</a></li><li><a class="tocitem" href="../../migration-guide-v2-v3/">Migration from v2 to v3</a></li><li><input class="collapse-toggle" id="menuitem-2-12" type="checkbox"/><label class="tocitem" for="menuitem-2-12"><span class="docs-label">Sharp bits of RxInfer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sharpbits/overview/">Overview</a></li><li><a class="tocitem" href="../../sharpbits/rule-not-found/">Rule Not Found Error</a></li><li><a class="tocitem" href="../../sharpbits/stack-overflow-inference/">Stack Overflow in Message Computations</a></li><li><a class="tocitem" href="../../sharpbits/usage-colon-equality/">Using <code>=</code> instead of <code>:=</code> for deterministic nodes</a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../../library/model-construction/">Model construction</a></li><li><a class="tocitem" href="../../../library/bethe-free-energy/">Bethe Free Energy</a></li><li><a class="tocitem" href="../../../library/functional-forms/">Functional form constraints</a></li><li><a class="tocitem" href="../../../library/exported-methods/">Exported methods</a></li></ul></li><li><a class="tocitem" href="../../../examples/overview/">Examples</a></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="../../../contributing/guide/">Contribution guide</a></li><li><a class="tocitem" href="../../../contributing/guidelines/">Contribution guidelines</a></li><li><a class="tocitem" href="../../../contributing/new-documentation/">Contributing to the documentation</a></li><li><a class="tocitem" href="../../../contributing/new-example/">Contributing to the examples</a></li><li><a class="tocitem" href="../../../contributing/new-release/">Publishing a new release</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User guide</a></li><li><a class="is-disabled">Inference customization</a></li><li class="is-active"><a href>Defining a custom node and rules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Defining a custom node and rules</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/RxInfer.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/RxInfer.jl/blob/main/docs/src/manuals/customization/custom-node.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="create-node"><a class="docs-heading-anchor" href="#create-node">Creating your own custom nodes</a><a id="create-node-1"></a><a class="docs-heading-anchor-permalink" href="#create-node" title="Permalink"></a></h1><p>Welcome to the <code>RxInfer</code> documentation on creating custom factor graph nodes. In <code>RxInfer</code>, factor nodes represent functional relationships between variables, also known as factors. Together, these factors define your probabilistic model. Quite often these factors represent distributions, denoting how a certain parameter affects another. However, other factors are also possible, such as ones specifying linear or non-linear relationships. <code>RxInfer</code> already supports a lot of factor nodes, however, depending on the problem that you are trying to solve, you may need to create a custom node that better fits the specific requirements of your model. This tutorial will guide you through the process of defining a custom node in <code>RxInfer</code>, step by step. By the end of this tutorial, you will be able to create your own custom node and integrate it into your model.</p><p>In addition, read another section on a different way of running inference with custom stochastic nodes without explicit rule specification <a href="../../inference/undefinedrules/#inference-undefinedrules">here</a>.</p><hr/><p>To create a custom node in <code>RxInfer</code>, 4 steps are required:</p><ol><li>Create your custom node in <code>RxInfer</code> using the <code>@node</code> macro.</li><li>Define the corresponding message passing update rules with the <code>@rule</code> macro. These rules specify how the node processes information in the form of messages, and how it communicates the results to adjacent parts of the model.</li><li>Specify computations for marginal distributions of the relevant variables with the <code>@marginalrule</code> macro.</li><li>Implement the computation of the Free Energy in a node with the <code>@average_energy</code> macro.</li></ol><p>Throughout this tutorial, we will create a node for the <code>Bernoulli</code> distribution. The <code>Bernoulli</code> distribution is a commonly used distribution in statistical modeling that is often used to model a binary outcome, such as a coin flip. By recreating this node, we will be able to demonstrate the process of creating a custom node, from notifying <code>RxInfer</code> of the nodes existence to implementing the required methods. While this tutorial focuses on the <code>Bernoulli</code> distribution, the principles can be applied to creating custom nodes for other distributions as well. So let&#39;s get started!</p><h2 id="Problem-statement"><a class="docs-heading-anchor" href="#Problem-statement">Problem statement</a><a id="Problem-statement-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-statement" title="Permalink"></a></h2><p>Jane wants to determine whether a coin is a fair coin, meaning that is equally likely to land on heads or tails. In order to determine this, she will throw the coin <span>$K=20$</span> times and write down how often it lands on heads and tails. The result of this experiment is a realization of the underlying stochastic process. Jane models the outcome of the experiment <span>$x_k\in\{0,1\}$</span> using the <a href="https://en.wikipedia.org/wiki/Bernoulli_distribution">Bernoulli distribution</a> as</p><p class="math-container">\[p(x_k \mid \pi) = \mathrm{Ber}(x_k \mid \pi) = \pi^{x_k} (1-\pi)^{1-x_k},\]</p><p>where <span>$\pi \in[0,1]$</span> denotes the probability that she throws heads, also known as the success probability. Jane also has a prior belief (initial guess) about the value of <span>$\pi$</span> which she models using the Beta distribution as</p><p class="math-container">\[p(\pi) = \mathrm{Beta}(\pi \mid 4, 8).\]</p><p>With this prior belief, the total probabilistic model that she has for this experiment is given by</p><p class="math-container">\[p(x_{1:K}, \pi) = p(\pi) \prod_{k=1}^K p(x_k \mid \pi).\]</p><p>Jane is interested in determining the fairness of the coin. Therefore she aims to infer (calculate) the posterior belief of <span>$\pi$</span>, <span>$p(\pi \mid x_{1:K})$</span>, denoting how <span>$\pi$</span> is distributed after we have seen the data.</p><hr/><h2 id="Step-1:-Creating-the-custom-node"><a class="docs-heading-anchor" href="#Step-1:-Creating-the-custom-node">Step 1: Creating the custom node</a><a id="Step-1:-Creating-the-custom-node-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Creating-the-custom-node" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In this example we will assume that the <code>Bernoulli</code> node and distribution do not yet exist. The <code>RxInfer</code> already defines the node for the <code>Bernoulli</code> distribution from the <code>Distributions.jl</code> package.</p></div></div><p>First things first, let&#39;s import <code>RxInfer</code>:</p><pre><code class="language-julia hljs">using RxInfer</code></pre><p>In order to define a custom node using the <code>@node</code> macro from <code>ReactiveMP</code>, we need the following three arguments:</p><ol><li>The name of the node.</li><li>Whether the node is <code>Deterministic</code> or <code>Stochastic</code>.</li><li>The interfaces of the node and any potential aliases.</li></ol><p>For the name of the node we wish to use <code>MyBernoulli</code> in this tutorial (<code>Bernoulli</code> already exists). However, the corresponding distribution does not yet exist. Therefore we need to specify it first as</p><pre><code class="language-julia hljs"># struct for Bernoulli distribution with success probability œÄ
struct MyBernoulli{T &lt;: Real} &lt;: ContinuousUnivariateDistribution
    œÄ :: T
end

# for simplicity, let&#39;s also specify the mean of the distribution
Distributions.mean(d::MyBernoulli) = d.œÄ</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can use regular functions, e.g <code>+</code> as a node type. Their Julia type, however, is written with the <code>typeof(_)</code> specification, e.g. <code>typeof(+)</code></p></div></div><p>For our node we are dealing with a stochastic node, because the node forms a probabilistic relationship. This means that for a given value of <span>$\pi$</span>, we do know the corresponding value of the output, but we do have some belief about this. Deterministic nodes include for example linear and non-linear transformation, such as <code>+</code> or <code>*</code>.</p><p>The interfaces specify what variables are connected to the node. The first argument is its output by convention. The ordering is important for both the model specification as the rule definition. As an example consider the <code>NormalMeanVariance</code> factor node. This factor node has interfaces <code>[out, Œº, v]</code> and can be called in the model specification language as <code>x ~ NormalMeanVariance(Œº, v)</code>. It is also possible to use aliases for the interfaces, which can be specified in a tuple as you will see below.</p><p>Concluding, we can create the <code>MyBernoulli</code> factor node as</p><pre><code class="language-julia hljs">@node MyBernoulli Stochastic [out, (œÄ, aliases = [p])]</code></pre><p>Cool! Step 1 is done, we have created a custom node.</p><hr/><h2 id="Step-2:-Defining-rules-for-our-node"><a class="docs-heading-anchor" href="#Step-2:-Defining-rules-for-our-node">Step 2: Defining rules for our node</a><a id="Step-2:-Defining-rules-for-our-node-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Defining-rules-for-our-node" title="Permalink"></a></h2><p>In order for <code>RxInfer</code> to perform probabilistic inference and compute posterior distributions, such as <span>$p(\pi\mid x_{1:K})$</span>, we need to tell it how to perform inference locally around our node. This localization is what makes <code>RxInfer</code> achieve high performance. In our message passing-based paradigm, we need to describe how the node processes incoming information in the form of messages (or marginals). Here we will highlight two different message passing strategies: sum-product message passing and variational message passing.</p><h3 id="Sum-product-message-passing-update-rules"><a class="docs-heading-anchor" href="#Sum-product-message-passing-update-rules">Sum-product message passing update rules</a><a id="Sum-product-message-passing-update-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Sum-product-message-passing-update-rules" title="Permalink"></a></h3><p>In sum-product message passing we compute outgoing messages to our node as</p><p class="math-container">\[\vec{\mu}(x) \propto \int \mathrm{Ber}(x\mid \pi) \vec{\mu}(\pi) \mathrm{d}x\]</p><p class="math-container">\[\overleftarrow{\mu}(\pi) \propto \sum_{x \in \{0,1\}} \mathrm{Ber}(x\mid \pi) \overleftarrow{\mu}(x)\]</p><p>This integral does not always have nice tractable solutions. However, for some forms of the incoming messages, it does yield a tractable solution.</p><p>For the case of a <code>Beta</code> message coming into our node, the outgoing message will be the predictive posterior of the <code>Bernoulli</code> distribution with a <code>Beta</code> prior. Here we obtain <span>$\pi = \frac{\alpha}{\alpha + \beta}$</span>, which coincides with the mean of the <code>Beta</code> distribution. Hence, we can write down the first update rule using the <code>@rule</code> macro as</p><pre><code class="language-julia hljs">@rule MyBernoulli(:out, Marginalisation) (m_œÄ :: Beta,) = MyBernoulli(mean(m_œÄ))</code></pre><p>Here, <code>:out</code> refers to the interface of the outgoing message. The second argument denotes the incoming messages (which can be typed) as a tuple. Therefore make sure that it has a trailing <code>,</code> when there is a single message coming in. <code>m_œÄ</code> is shorthand for <em>the incoming message on interface <code>œÄ</code></em>. As we will see later, the structured approximation update rule for incoming message from <code>œÄ</code> will have <code>q_œÄ</code> as parameter.</p><p>The second rule is also straightforward; if <code>œÄ</code> is a <code>PointMass</code> and therefore fixed, the outgoing message will be <code>MyBernoulli(œÄ)</code>:</p><pre><code class="language-julia hljs">@rule MyBernoulli(:out, Marginalisation) (m_œÄ :: PointMass,) = MyBernoulli(mean(m_œÄ))</code></pre><p>Continuing with the sum-product update rules, we now have to define the update rules towards the <code>œÄ</code> interface. We can only do exact inference if the incoming message is known, which in the case of the <code>Bernoulli</code> distribution, means that the <code>out</code> message is a <code>PointMass</code> distribution that is either <code>0</code> or <code>1</code>. The updated Beta distribution for <code>œÄ</code> will be:</p><p class="math-container">\[\overleftarrow{\mu}(œÄ) \propto \mathrm{Beta}(1 + x, 2 - x)\]</p><p>Which gives us the following update rule:</p><pre><code class="language-julia hljs">@rule MyBernoulli(:œÄ, Marginalisation) (m_out :: PointMass,) = begin
    p = mean(m_out)
    return Beta(one(p) + p, 2one(p) - p)
end</code></pre><h3 id="Variational-message-passing-update-rules"><a class="docs-heading-anchor" href="#Variational-message-passing-update-rules">Variational message passing update rules</a><a id="Variational-message-passing-update-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Variational-message-passing-update-rules" title="Permalink"></a></h3><p>We will now cover our second set of update rules. The sum-product messages are not always tractable and therefore we may need to resort to approximations. Here we highlight the variational approximation. In variational message passing we compute outgoing messages to our node as</p><p class="math-container">\[\vec{\nu}(x) \propto \exp \int q(\pi) \ln \mathrm{Ber}(x\mid \pi) \mathrm{d}x\]</p><p class="math-container">\[\overleftarrow{\nu}(\pi) \propto \exp \sum_{x \in \{0,1\}} q(x) \ln \mathrm{Ber}(x\mid \pi)\]</p><p>These messages depend on the marginals on the adjacent edges and not on the incoming messages as was the case with sum-product message passing. Update rules that operate on the marginals instead of the incoming messages are specified with the <code>q_{interface}</code> argument names. With these update rules, we can often support a wider family of distributions. Below we directly give the variational update rules. Deriving them yourself will be a nice challenge.</p><pre><code class="language-julia hljs">#rules towards out
@rule MyBernoulli(:out, Marginalisation) (q_œÄ :: PointMass,) = MyBernoulli(mean(q_œÄ))

@rule Bernoulli(:out, Marginalisation) (q_œÄ::Any,) = begin
    rho_1 = mean(log, q_œÄ)          # E[ln(x)]
    rho_2 = mean(mirrorlog, q_œÄ)    # E[log(1-x)]
    m = max(rho_1, rho_2)
    tmp = exp(rho_1 - m)
    p = clamp(tmp / (tmp + exp(rho_2 - m)), tiny, one(m))
    return Bernoulli(p)
end

#rules towards œÄ
@rule MyBernoulli(:œÄ, Marginalisation) (q_out :: Any,) = begin
    p = mean(q_out)
    return Beta(one(p) + p, 2one(p) - p)
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Typically, the type of the variational distributions <code>q_</code> does not matter in the real computations, but only their statistics, e.g <code>mean</code> or <code>var</code>. Thus, in this case, we may safely use <code>::Any</code>.</p></div></div><p>In the example that we will show later on, we solely use sum-product message passing. Variational message passing requires us to set the local constraints in our model, something which is out of scope of this tutorial.</p><hr/><h2 id="Step-3:-Defining-joint-marginals-for-our-node"><a class="docs-heading-anchor" href="#Step-3:-Defining-joint-marginals-for-our-node">Step 3: Defining joint marginals for our node</a><a id="Step-3:-Defining-joint-marginals-for-our-node-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Defining-joint-marginals-for-our-node" title="Permalink"></a></h2><p>The entire probabilistic model can be scored using the Bethe free energy, which bounds the log-evidence for acyclic graphs. This Bethe free energy consists out of the sum of node-local entropies, negative node-local average energies and edge specific entropies. Formally we can denote this by</p><p class="math-container">\[F[q,f] = - \sum_{a\in\mathcal{V}} \mathrm{H}[q_a(s_a)] - \sum_{a\in\mathcal{V}}\mathrm{E}_{q_a(s_a)}[\ln f_a(s_a)] + \sum_{i\in\mathcal{E}}\mathrm{H}[q_i(s_i)]\]</p><p>Here we call <span>$q_a(s_a)$</span> the joint marginals around a node and <span>$-\mathrm{E}_{q_a(s_a)}[\ln f_a(s_a)]$</span> we term the average energy.</p><p>In order to be able to compute the Bethe free energy, we need to first describe how to compute <span>$q_a(s_a)$</span>, defined in our case as </p><p class="math-container">\[q(x_k, \pi) = \vec{\mu}(\pi) \overleftarrow{\mu}(x_k) \mathrm{Ber}(x_k \mid \pi)\]</p><p>To calculate the updated posterior marginal for our custom distribution, we need to return joint posterior marginals for the interfaces of our node. In our case, the posterior marginal for the observation is still the same <code>PointMass</code> distribution. However, to calculate the posterior marginal over <code>œÄ</code>, we use <code>RxInfer</code>&#39;s built-in <code>prod</code> functionality to multiply the <code>Beta</code> prior with the <code>Beta</code> likelihood. This gives us the updated posterior distribution, which is also a <code>Beta</code> distribution. We use <code>PreserveTypeProd(Distribution)</code> parameter to ensure that we multiply the two distributions analytically. This is done as follows:</p><pre><code class="language-julia hljs">@marginalrule MyBernoulli(:out_œÄ) (m_out::PointMass, m_œÄ::Beta) = begin
    r = mean(m_out)
    p = prod(PreserveTypeProd(Distribution), Beta(one(r) + r, 2one(r) - r), m_œÄ)
    return (out = m_out, p = p)
end</code></pre><p>In this code <code>:out_œÄ</code> describes the arguments of the joint marginal distribution. The second argument contains the incoming messages. Here we know from the model specification that we observe <code>out</code> and therefore this has to be a <code>PointMass</code>. Because it is a <code>PointMass</code>, the joint marginal automatically factorizes as <span>$q(x_k, \pi) = q(x_k)q(\pi)$</span>. These are the distributions that we return in a form of the <code>NamedTuple</code>. <code>NamedTuple</code> is used only in cases where we know that the joint marginal factorizes further, but typically it should be a full distribution. For computing <span>$q(\pi)$</span> we need to compute the product <span>$\vec{\mu}(\pi)\overleftarrow{\mu}(\pi)$</span>. We already know how <span>$\overleftarrow{\mu}(\pi)$</span> looks like from the previous step, so we can just use the <code>prod</code> function.</p><hr/><h2 id="Step-4:-Defining-the-average-energy-for-our-node"><a class="docs-heading-anchor" href="#Step-4:-Defining-the-average-energy-for-our-node">Step 4: Defining the average energy for our node</a><a id="Step-4:-Defining-the-average-energy-for-our-node-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Defining-the-average-energy-for-our-node" title="Permalink"></a></h2><p>To complete the computation of the Bethe free energy, we also need to compute the average energy term. The average energy in our <code>MyBernoulli</code> example can be computed as <span>$-\mathrm{E}_{q(x_k, \pi)}[\ln p(x_k \mid \pi)]$</span>, however, because we know that we observe <span>$x_k$</span> and therefore <span>$q(x_k, \pi)$</span> factorizes, we can instead compute <span>$\begin{aligned} -\mathrm{E}_{q(x_k)q(\pi)}[\ln p(x_k \mid \pi)] &amp;= -\mathrm{E}_{q(x_k)q(\pi)} [\ln (\pi^{x_k} (1-\pi)^{1 - x_k})] \\
&amp;= -\mathrm{E}_{q(x_k)q(\pi)} [x_k \ln(\pi) + (1-x_k) \ln(1-\pi)] \\
&amp;= -\mathrm{E}_{q(x_k)}[x_k] \mathrm{E}_{q(\pi)} [\ln(\pi)] - (1-\mathrm{E}_{q(x_k)}[x_k]) \mathrm{E}_{q(\pi)}[\ln(1-\pi)] \end{aligned}$</span></p><p>Which is what we implemented below. Note that <code>mean(mirrorlog, q(x))</code> is equal to <span>$\mathrm{E}_{q(x)}[1-\log{x}]$</span>.</p><pre><code class="language-julia hljs">@average_energy Bernoulli (q_out::Any, q_œÄ::Any) = -mean(q_out) * mean(log, q_œÄ) - (1.0 - mean(q_out)) * mean(mirrorlog, q_œÄ)</code></pre><p>In the case that the interfaces do not factorize, we would get something like <code>@average_energy MyBernoulli (q_out_œÄ::Any,) = begin ... end</code>.</p><h2 id="Using-our-node-in-a-model"><a class="docs-heading-anchor" href="#Using-our-node-in-a-model">Using our node in a model</a><a id="Using-our-node-in-a-model-1"></a><a class="docs-heading-anchor-permalink" href="#Using-our-node-in-a-model" title="Permalink"></a></h2><p>With all the necessary functions defined, we can proceed to test our custom node in an experiment. For this experiment, we will generate a dataset from a <code>Bernoulli</code> distribution with a fixed success probability of <code>0.75</code>. Next, we will define a probabilistic model that has a <code>Beta</code> prior and a <code>MyBernoulli</code> likelihood. The <code>Beta</code> prior will be used to model our prior belief about the probability of success. The <code>MyBernoulli</code> likelihood will be used to model the generative process of the observed data. We start by generating the dataset:</p><pre><code class="language-julia hljs">using Random

rng = MersenneTwister(42)
n = 500
œÄ_real = 0.75
distribution = Bernoulli(œÄ_real)

dataset = float.(rand(rng, distribution, n))</code></pre><p>Next, we define our model. Note that we use the <code>MyBernoulli</code> node in the model. The model consists of a single latent variable <code>œÄ</code>, which has a <code>Beta</code> prior and is the parameter of the <code>MyBernoulli</code> likelihood. The <code>MyBernoulli</code> node takes the value of <code>œÄ</code> as its parameter and returns a binary observation. We set the hyperparameters of the <code>Beta</code> prior to be 4 and 8, respectively, which correspond to a distribution slightly biased towards higher values of <code>œÄ</code>. The model is defined as follows:</p><pre><code class="language-julia hljs">@model function coin_model_mybernoulli(y)
    # We endow Œ∏ parameter of our model with some prior
    œÄ ~ Beta(4.0, 8.0)
    # We assume that outcome of each coin flip is governed by the MyBernoulli distribution
    for i in eachindex(y)
        y[i] ~ MyBernoulli(œÄ)
    end
end</code></pre><p>Finally, we can run inference with this model and the generated dataset:</p><pre><code class="language-julia hljs">result_mybernoulli = infer(
    model = coin_model_mybernoulli(),
    data  = (y = dataset, ),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inference results:
  Posteriors       | available for (œÄ)
</code></pre><p>We have now completed our experiment and obtained the posterior marginal distribution for p through inference. To evaluate the performance of our inference, we can compare the estimated posterior to the true value. In our experiment, the true value for p is <code>0.75</code>, and we can see that the estimated posterior has a mean close to this value, which shows that our custom node was able to successfully pass messages towards the <code>œÄ</code> variable in order to learn the true value of the parameter.</p><pre><code class="language-julia hljs">using Plots

rŒ∏ = range(0, 1, length = 1000)

p = plot(title = &quot;Inference results&quot;)

plot!(rŒ∏, (x) -&gt; pdf(result_mybernoulli.posteriors[:œÄ], x), fillalpha=0.3, fillrange = 0, label=&quot;p(œÄ|x)&quot;, c=3)
vline!([œÄ_real], label=&quot;Real œÄ&quot;)</code></pre><img src="a2a4bca8.svg" alt="Example block output"/><p>As a sanity check, we can create the same model with the <code>RxInfer</code> built-in node <code>Bernoulli</code> and compare the resulting posterior distribution with the one obtained using our custom <code>MyBernoulli</code> node. This will give us confidence that our custom node is working correctly. We use the <code>Bernoulli</code> node with the same <code>Beta</code> prior and the observed data, and then run inference. We can compare the two posterior distributions and observe that they are exactly the same, which indicates that our custom node is performing as expected.</p><pre><code class="language-julia hljs">@model function coin_model(y)
    p ~ Beta(4.0, 8.0)
    for i in eachindex(y)
        y[i] ~ Bernoulli(p)
    end
end

result_bernoulli = infer(
    model = coin_model(),
    data  = (y = dataset, ),
)

if !(result_bernoulli.posteriors[:p] == result_mybernoulli.posteriors[:œÄ])
    error(&quot;Results are not identical&quot;)
else
    println(&quot;Results are identical üéâüéâüéâ&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Results are identical üéâüéâüéâ</code></pre><p>Congratulations! You have successfully implemented your own custom node in <code>RxInfer</code>. We went through the definition of a node to the implementation of the update rules and marginal posterior calculations. Finally we tested our custom node in a model and checked if we implemented everything correctly.</p><h1 id="custom-node-experimental"><a class="docs-heading-anchor" href="#custom-node-experimental">Custom node experimental functionality</a><a id="custom-node-experimental-1"></a><a class="docs-heading-anchor-permalink" href="#custom-node-experimental" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Experimental features</header><div class="admonition-body"><p>The functionality described below is experimental and subject to change in future releases. Use it with caution in production code.</p></div></div><h2 id="inference-ruleswithnode"><a class="docs-heading-anchor" href="#inference-ruleswithnode">Rules that require a reference to a node object</a><a id="inference-ruleswithnode-1"></a><a class="docs-heading-anchor-permalink" href="#inference-ruleswithnode" title="Permalink"></a></h2><p>In some advanced scenarios, you might need access to the node object itself within a message passing rule. This can be useful when:</p><ul><li>You need to inspect the current state of other variables in the model</li><li>You want to implement complex message passing schemes that depend on the global model state</li><li>You&#39;re experimenting with custom inference algorithms that require access to the factor graph structure</li></ul><p>Here&#39;s how to implement a rule with node access. First we define a custom node and a simple model that uses this node:</p><pre><code class="language-julia hljs">using RxInfer

struct MyExperimentalNode end

@node MyExperimentalNode Stochastic [ out, Œ∏ ]

@model function my_experimental_model(y)
    Œ∏ ~ Normal(mean = 0.0, variance = 1.0)
    y ~ MyExperimentalNode(Œ∏)
end</code></pre><p>Second, we enable instruction to the inference backend to pass node reference to the rule.</p><pre><code class="language-julia hljs"># Enable node reference passing for this node type
ReactiveMP.call_rule_is_node_required(::Type{&lt;:MyExperimentalNode}) = ReactiveMP.CallRuleNodeRequired()</code></pre><div class="admonition is-info"><header class="admonition-header">Performance Impact</header><div class="admonition-body"><p>Enabling node reference passing can negatively impact performance as it requires additional bookkeeping during inference.</p></div></div><div class="admonition is-danger"><header class="admonition-header">Global State</header><div class="admonition-body"><p>Setting <code>call_rule_is_node_required</code> for existing nodes (like <code>NormalMeanVariance</code>) affects all models globally and will affect code that depends on your package. Only safe to use this for your custom nodes.</p></div></div><p>The <code>call_rule_is_node_required</code> function is used to instruct the inference backend to pass the node object to the rule. After this is set, we can use the <code>getnode()</code> function to access the node object within the rule.</p><pre><code class="language-julia hljs">@rule MyExperimentalNode(:Œ∏, Marginalisation) (q_out::Any, ) = begin
    node = getnode()
    # Access interface index
    ii = ReactiveMP.interfaceindex(node, :Œ∏)
    # Get interface object
    Œ∏i = ReactiveMP.getinterfaces(node)[ii]
    # Get variable object
    Œ∏v = ReactiveMP.getvariable(Œ∏i)

    # By default, `germarginal` ignores marginals set in the @initialization block
    # `IncludeAll` overrides this behavior and includes all marginals
    qŒ∏ = Rocket.getrecent(ReactiveMP.getmarginal(Œ∏v, IncludeAll()))

    # This is a simple rule that returns a NormalMeanVariance distribution
    # It could be replaced with any other rule that returns a distribution
    return NormalMeanVariance(mean(qŒ∏) + mean(q_out), var(qŒ∏))
end</code></pre><h3 id="Running-inference-with-the-custom-node-and-rule"><a class="docs-heading-anchor" href="#Running-inference-with-the-custom-node-and-rule">Running inference with the custom node and rule</a><a id="Running-inference-with-the-custom-node-and-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Running-inference-with-the-custom-node-and-rule" title="Permalink"></a></h3><p>Here&#39;s a full example showing how to use this functionality:</p><pre><code class="language-julia hljs">initialization = @initialization begin
    q(Œ∏) = NormalMeanVariance(3.14, 2.71)
end

result = infer(
    model = my_experimental_model(),
    data = (y = 1.0, ),
    initialization = initialization
)</code></pre><p>As we can see, the print statement in the rule is executed, which means that the node reference passing is working as expected. This feature opens up possibilities for advanced inference scenarios, but should be used judiciously. Consider whether your use case truly requires access to the node object, as simpler solutions using standard message passing rules are often sufficient and more maintainable.</p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../inference/undefinedrules/">¬´ Undefined message update rules</a><a class="docs-footer-nextpage" href="../postprocess/">Inference results postprocessing ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Created in <a href="https://biaslab.github.io/">BIASlab</a>, maintained by <a href="https://github.com/ReactiveBayes">ReactiveBayes</a>, powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 19 February 2025 14:14">Wednesday 19 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
