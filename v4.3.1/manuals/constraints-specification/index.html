<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraints specification · RxInfer.jl</title><meta name="title" content="Constraints specification · RxInfer.jl"/><meta property="og:title" content="Constraints specification · RxInfer.jl"/><meta property="twitter:title" content="Constraints specification · RxInfer.jl"/><meta name="description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="og:description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="twitter:description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="og:url" content="https://docs.rxinfer.com/stable/manuals/constraints-specification/"/><meta property="twitter:url" content="https://docs.rxinfer.com/stable/manuals/constraints-specification/"/><link rel="canonical" href="https://docs.rxinfer.com/stable/manuals/constraints-specification/"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-X4PH160GMF"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-X4PH160GMF', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/theme.css" rel="stylesheet" type="text/css"/><link href="../../assets/header.css" rel="stylesheet" type="text/css"/><script src="../../assets/header.js"></script><script src="../../assets/chat.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><meta name="keywords" content="Julia, Bayesian inference, factor graph, message passing, probabilistic programming, reactive programming, RxInfer">
<link rel="sitemap" type="application/xml" title="Sitemap" href="https://docs.rxinfer.com/stable/sitemap.xml"></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="RxInfer.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="RxInfer.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../comparison/">RxInfer.jl vs. Others</a></li><li><a class="tocitem" href="../model-specification/">Model specification</a></li><li class="is-active"><a class="tocitem" href>Constraints specification</a><ul class="internal"><li><a class="tocitem" href="#user-guide-constraints-specification-background"><span>Background and example</span></a></li><li><a class="tocitem" href="#General-syntax"><span>General syntax</span></a></li><li><a class="tocitem" href="#Marginal-and-messages-form-constraints"><span>Marginal and messages form constraints</span></a></li><li><a class="tocitem" href="#Factorization-constraints-on-posterior-distribution-q"><span>Factorization constraints on posterior distribution <code>q</code></span></a></li><li><a class="tocitem" href="#Constraints-in-submodels"><span>Constraints in submodels</span></a></li><li><a class="tocitem" href="#Default-constraints"><span>Default constraints</span></a></li><li><a class="tocitem" href="#Constraints-on-the-data"><span>Constraints on the data</span></a></li><li><a class="tocitem" href="#prespecified-constraints"><span>Prespecified constraints</span></a></li></ul></li><li><a class="tocitem" href="../meta-specification/">Meta specification</a></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Inference specification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../inference/overview/">Overview</a></li><li><a class="tocitem" href="../inference/static/">Static inference</a></li><li><a class="tocitem" href="../inference/streamlined/">Streamline inference</a></li><li><a class="tocitem" href="../inference/initialization/">Initialization</a></li><li><a class="tocitem" href="../inference/autoupdates/">Auto-updates</a></li><li><a class="tocitem" href="../inference/delta-node/">Deterministic nodes</a></li><li><a class="tocitem" href="../inference/nonconjugate/">Non-conjugate inference</a></li><li><a class="tocitem" href="../inference/undefinedrules/">Undefined message update rules</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Inference customization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../customization/custom-node/">Defining a custom node and rules</a></li><li><a class="tocitem" href="../customization/postprocess/">Inference results postprocessing</a></li></ul></li><li><a class="tocitem" href="../debugging/">Debugging</a></li><li><a class="tocitem" href="../session_summary/">Session summary</a></li><li><a class="tocitem" href="../telemetry/">Sharing sessions &amp; telemetry</a></li><li><a class="tocitem" href="../migration-guide-v2-v3/">Migration from v2 to v3</a></li><li><input class="collapse-toggle" id="menuitem-2-12" type="checkbox"/><label class="tocitem" for="menuitem-2-12"><span class="docs-label">Sharp bits of RxInfer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sharpbits/overview/">Overview</a></li><li><a class="tocitem" href="../sharpbits/rule-not-found/">Rule Not Found Error</a></li><li><a class="tocitem" href="../sharpbits/stack-overflow-inference/">Stack Overflow in Message Computations</a></li><li><a class="tocitem" href="../sharpbits/usage-colon-equality/">Using <code>=</code> instead of <code>:=</code> for deterministic nodes</a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/model-construction/">Model construction</a></li><li><a class="tocitem" href="../../library/bethe-free-energy/">Bethe Free Energy</a></li><li><a class="tocitem" href="../../library/functional-forms/">Functional form constraints</a></li><li><a class="tocitem" href="../../library/exported-methods/">Exported methods</a></li></ul></li><li><a class="tocitem" href="../../examples/overview/">Examples</a></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="../../contributing/guide/">Contribution guide</a></li><li><a class="tocitem" href="../../contributing/guidelines/">Contribution guidelines</a></li><li><a class="tocitem" href="../../contributing/new-documentation/">Contributing to the documentation</a></li><li><a class="tocitem" href="../../contributing/new-example/">Contributing to the examples</a></li><li><a class="tocitem" href="../../contributing/new-release/">Publishing a new release</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User guide</a></li><li class="is-active"><a href>Constraints specification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constraints specification</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/RxInfer.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/RxInfer.jl/blob/main/docs/src/manuals/constraints-specification.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="user-guide-constraints-specification"><a class="docs-heading-anchor" href="#user-guide-constraints-specification">Constraints Specification</a><a id="user-guide-constraints-specification-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-constraints-specification" title="Permalink"></a></h1><p><code>RxInfer.jl</code> uses a macro called <code>@constraints</code> from <code>GraphPPL</code> to add extra constraints during the inference process. For details on using the <code>@constraints</code> macro, you can check out the <a href="https://reactivebayes.github.io/GraphPPL.jl/stable/">official documentation</a> of GraphPPL.</p><h2 id="user-guide-constraints-specification-background"><a class="docs-heading-anchor" href="#user-guide-constraints-specification-background">Background and example</a><a id="user-guide-constraints-specification-background-1"></a><a class="docs-heading-anchor-permalink" href="#user-guide-constraints-specification-background" title="Permalink"></a></h2><p>Here we briefly cover the mathematical aspects of constraints specification. For additional information and relevant links, please refer to the <a href="../../library/bethe-free-energy/#lib-bethe-free-energy">Bethe Free Energy</a> section. In essence, <code>RxInfer</code> performs Variational Inference (via message passing) given specific constraints <span>$\mathcal{Q}$</span>:</p><p class="math-container">\[q^* = \arg\min_{q(s) \in \mathcal{Q}}F[q](\hat{y}) = \mathbb{E}_{q(s)}\left[\log \frac{q(s)}{p(s, y=\hat{y})} \right]\,.\]</p><p>The <a href="../../library/model-construction/#RxInfer.@model"><code>@model</code></a> macro specifies generative model <code>p(s, y)</code> where <code>s</code> is a set of random variables and <code>y</code> is a set of observations. In a nutshell the goal of probabilistic programming is to find <code>p(s|y)</code>. <code>RxInfer</code> approximates <code>p(s|y)</code> with a proxy distribution <code>q(x)</code> using KL divergence and Bethe Free Energy optimisation procedure. By default there are no extra factorization constraints on <code>q(s)</code> and the optimal solution is <code>q(s) = p(s|y)</code>.</p><p>For certain problems, it may be necessary to adjust the set of constraints <span>$\mathcal{Q}$</span> (also known as the variational family of distributions) to either improve accuracy at the expense of computational resources or reduce accuracy to conserve computational resources. Sometimes, we are compelled to impose certain constraints because otherwise, the problem becomes too challenging to solve within a reasonable timeframe.</p><p>For instance, consider the following model:</p><pre><code class="language-julia hljs">using RxInfer

@model function iid_normal(y)
    μ  ~ Normal(mean = 0.0, variance = 1.0)
    τ  ~ Gamma(shape = 1.0, rate = 1.0)
    y .~ Normal(mean = μ, precision = τ)
end</code></pre><p>In this model, we characterize all observations in a dataset y as a <code>Normal</code> distribution with mean <code>μ</code> and precision <code>τ</code>. It&#39;s reasonable to assume that the latent variables <code>μ</code> and <code>τ</code> are jointly independent, thereby rendering their joint posterior distribution as:</p><p class="math-container">\[q(μ, τ) = q(μ)q(τ)\,.\]</p><p>If we would write the variational family of distribution for such an assumption, it would be expressed as:</p><p class="math-container">\[\mathcal{Q} = \left\{ q : q(μ, τ) = q(μ)q(τ) \right\}\,.\]</p><p>We can express this constraint with the <code>@constraints</code> macro:</p><pre><code class="language-julia hljs">constraints = @constraints begin
    q(μ, τ) = q(μ)q(τ)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q(μ, τ) = q(μ)q(τ)
</code></pre><p>and use the created <code>constraints</code> object to the <a href="../inference/overview/#RxInfer.infer"><code>infer</code></a> function:</p><pre><code class="language-julia hljs"># We need to specify initial marginals, since with the constraints
# the problem becomes inherently iterative (we could also specify initial for the `μ` instead)
init = @initialization begin
    q(τ) = vague(Gamma)
end

result = infer(
    model       = iid_normal(),
    # Sample data from mean `3.1415` and precision `2.7182`
    data        = (y = rand(NormalMeanPrecision(3.1415, 2.7182), 1000), ),
    constraints = constraints,
    initialization = init,
    iterations     = 25
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inference results:
  Posteriors       | available for (μ, τ)
</code></pre><pre><code class="language-julia hljs">println(&quot;Estimated mean of `μ` is &quot;, mean(result.posteriors[:μ][end]), &quot; with standard deviation &quot;, std(result.posteriors[:μ][end]))
println(&quot;Estimated mean of `τ` is &quot;, mean(result.posteriors[:τ][end]), &quot; with standard deviation &quot;, std(result.posteriors[:τ][end]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Estimated mean of `μ` is 3.1243874904829134 with standard deviation 0.020113707610946375
Estimated mean of `τ` is 2.470813699157848 with standard deviation 0.11038781514473109</code></pre><p>We observe that the estimates tend to slightly deviate from what the real values are.  This behavior is a known characteristic of inference with the aforementioned constraints, often referred to as <em>Mean Field</em> constraints.</p><h2 id="General-syntax"><a class="docs-heading-anchor" href="#General-syntax">General syntax</a><a id="General-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#General-syntax" title="Permalink"></a></h2><p>You can use the <code>@constraints</code> macro with either a regular Julia function or a single <code>begin ... end</code> block. Both ways are valid, as shown below:</p><pre><code class="language-julia hljs"># `functional` style
@constraints function create_my_constraints()
    q(μ, τ) = q(μ)q(τ)
end

# `block` style
myconstraints = @constraints begin
    q(μ, τ) = q(μ)q(τ)
end</code></pre><p>The function-based syntax can also take arguments, like this:</p><pre><code class="language-julia hljs">@constraints function make_constraints(mean_field)
    # Specify mean-field only if the flag is `true`
    if mean_field
        q(μ, τ) = q(μ)q(τ)
    end
end

myconstraints = make_constraints(true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q(μ, τ) = q(μ)q(τ)
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>RxInfer</code> exports <code>MeanField</code> and other prespecified constraints as convenient aliases that can be used directly in the <code>constraints</code> argument of <a href="../inference/overview/#RxInfer.infer"><code>infer</code></a>. See <a href="#prespecified-constraints">Prespecified constraints</a> below for more details.</p></div></div><h2 id="Marginal-and-messages-form-constraints"><a class="docs-heading-anchor" href="#Marginal-and-messages-form-constraints">Marginal and messages form constraints</a><a id="Marginal-and-messages-form-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Marginal-and-messages-form-constraints" title="Permalink"></a></h2><p>To specify marginal or messages form constraints <code>@constraints</code> macro uses <code>::</code> operator (in somewhat similar way as Julia uses it for multiple dispatch type specification). Read more about available functional form constraints in the <a href="../../library/functional-forms/#lib-forms">Built-In Functional Forms</a> section.</p><p>As an example, the following constraint:</p><pre><code class="language-julia hljs">@constraints begin
    q(x) :: PointMassFormConstraint()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q(x) :: PointMassFormConstraint()
</code></pre><p>indicates that the resulting marginal of the variable (or array of variables) named <code>x</code> must be approximated with a <code>PointMass</code> object. Message passing based algorithms compute posterior marginals as a normalized product of two colliding messages on corresponding edges of a factor graph. In a few words <code>q(x)::PointMassFormConstraint</code> reads as:</p><p class="math-container">\[\mathrm{approximate~} q(x) = \frac{\overrightarrow{\mu}(x)\overleftarrow{\mu}(x)}{\int \overrightarrow{\mu}(x)\overleftarrow{\mu}(x) \mathrm{d}x}\mathrm{~as~PointMass}\]</p><p>Sometimes it might be useful to set a functional form constraint on messages too. For example if it is essential to keep a specific Gaussian parametrisation or if some messages are intractable and need approximation. To set messages form constraint <code>@constraints</code> macro uses <code>μ(...)</code> instead of <code>q(...)</code>:</p><pre><code class="language-julia hljs">@constraints begin
    q(x) :: PointMassFormConstraint()
    μ(x) :: SampleListFormConstraint(1000)
    # it is possible to assign different form constraints on the same variable
    # both for the marginal and for the messages
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q(x) :: PointMassFormConstraint()
  μ(x) :: SampleListFormConstraint(Random.TaskLocalRNG(), AutoProposal(), BayesBase.BootstrapImportanceSampling())
</code></pre><p><code>@constraints</code> macro understands &quot;stacked&quot; form constraints. For example the following form constraint</p><pre><code class="language-julia hljs">@constraints begin
    q(x) :: SampleListFormConstraint(1000) :: PointMassFormConstraint()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q(x) :: (SampleListFormConstraint(Random.TaskLocalRNG(), AutoProposal(), BayesBase.BootstrapImportanceSampling()), PointMassFormConstraint())
</code></pre><p>indicates that the <code>q(x)</code> first must be approximated with a <code>SampleList</code> and in addition the result of this approximation should be approximated as a <code>PointMass</code>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Not all combinations of &quot;stacked&quot; form constraints are compatible between each other.</p></div></div><p>You can find more information about built-in functional form constraint in the <a href="../../library/functional-forms/#lib-forms">Built-in Functional Forms</a> section. In addition, the <a href="https://reactivebayes.github.io/ReactiveMP.jl/stable/">ReactiveMP library documentation</a> explains the functional form interfaces and shows how to build a custom functional form constraint that is compatible with <code>RxInfer.jl</code> and <code>ReactiveMP.jl</code> inference engine.</p><h2 id="Factorization-constraints-on-posterior-distribution-q"><a class="docs-heading-anchor" href="#Factorization-constraints-on-posterior-distribution-q">Factorization constraints on posterior distribution <code>q</code></a><a id="Factorization-constraints-on-posterior-distribution-q-1"></a><a class="docs-heading-anchor-permalink" href="#Factorization-constraints-on-posterior-distribution-q" title="Permalink"></a></h2><p>As has been mentioned <a href="#user-guide-constraints-specification-background">above</a>, inference may be not tractable for every model without extra factorization constraints. To circumvent this, <code>RxInfer.jl</code> allows for extra factorization constraints, for example:</p><pre><code class="language-julia hljs">@constraints begin
    q(x, y) = q(x)q(y)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q(x, y) = q(x)q(y)
</code></pre><p>specifies a so-called mean-field assumption on variables <code>x</code> and <code>y</code> in the model. Furthermore, if <code>x</code> is an array of variables in our model we may induce extra mean-field assumption on <code>x</code> in the following way.</p><pre><code class="language-julia hljs">@constraints begin
    q(x) = q(x[begin])..q(x[end])
    q(x, y) = q(x)q(y)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q(x) = q(x[(begin)..(end)])
  q(x, y) = q(x)q(y)
</code></pre><p>These constraints specify a mean-field assumption between variables <code>x</code> and <code>y</code> (either single variable or collection of variables) and additionally specify mean-field assumption on variables <span>$x_i$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@constraints</code> macro does not support matrix-based collections of variables. E.g. it is not possible to write <code>q(x[begin, begin])..q(x[end, end])</code>. Use <code>q(x[begin])..q(x[end])</code> instead.</p></div></div><p>Read more about the <code>@constraints</code> macro in the <a href="https://reactivebayes.github.io/GraphPPL.jl/stable/">official documentation</a> of GraphPPL</p><h2 id="Constraints-in-submodels"><a class="docs-heading-anchor" href="#Constraints-in-submodels">Constraints in submodels</a><a id="Constraints-in-submodels-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints-in-submodels" title="Permalink"></a></h2><p><code>RxInfer</code> allows you to define your generative model hierarchically, using previously defined <code>@model</code> modules as submodels in larger models. Because of this, users need to specify their constraints hierarchically as well to avoid ambiguities. Consider the following example:</p><pre><code class="language-julia hljs">@model function inner_inner(τ, y)
    y ~ Normal(mean = τ[1], var = τ[2])
end

@model function inner(θ, α)
    β ~ Normal(mean = 0.0, var = 1.0)
    α ~ Gamma(shape = β, rate = 1.0)
    α ~ inner_inner(τ = θ)
end

@model function outer()
    local w
    for i = 1:5
        w[i] ~ inner(θ = Gamma(shape = 1.0, rate = 1.0))
    end
    y ~ inner(θ = w[2:3])
end</code></pre><p>To access the variables in the submodels, we use the <code>for q in __submodel__</code> syntax, which will allow us to specify constraints over variables in the context of an inner submodel:</p><pre><code class="language-julia hljs">@constraints begin
    for q in inner
        q(α) :: PointMassFormConstraint()
        q(α, β) = q(α)q(β)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q(inner) = 
    q(α, β) = q(α)q(β)
    q(α) :: PointMassFormConstraint()

</code></pre><p>Similarly, we can specify constraints over variables in the context of the innermost submodel by using the <code>for q in __submodel__</code> syntax twice:</p><pre><code class="language-julia hljs">@constraints begin
    for q in inner
        for q in inner_inner
            q(y, τ) = q(y)q(τ[1])q(τ[2])
        end
        q(α) :: PointMassFormConstraint()
        q(α, β) = q(α)q(β)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q(inner) = 
    q(α, β) = q(α)q(β)
    q(α) :: PointMassFormConstraint()
    q(inner_inner) = 
        q(y, τ) = q(y)q(τ[1])q(τ[2])


</code></pre><p>The <code>for q in __submodel__</code> applies the constraints specified in this code block to all instances of <code>__submodel__</code> in the current context. If we want to apply constraints to a specific instance of a submodel, we can use the <code>for q in (__submodel__, __identifier__)</code> syntax, where <code>__identifier__</code> is a counter integer. For example, if we want to specify constraints on the first instance of <code>inner</code> in our <code>outer</code> model, we can do so with the following syntax:</p><pre><code class="language-julia hljs">@constraints begin
    for q in (inner, 1)
        q(α) :: PointMassFormConstraint()
        q(α, β) = q(α)q(β)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q((inner, 1)) = 
    q(α, β) = q(α)q(β)
    q(α) :: PointMassFormConstraint()

</code></pre><p>Factorization constraints specified in a context propagate to their child submodels. This means that we can specify factorization constraints over variables where the factor node that connects the two are in a submodel, without having to specify the factorization constraint in the submodel itself. For example, if we want to specify a factorization constraint between <code>w[2]</code> and <code>w[3]</code> in our <code>outer</code> model, we can specify it in the context of <code>outer</code>, and <code>RxInfer</code> will recognize that these variables are connected through the <code>Normal</code> node in the <code>inner_inner</code> submodel:</p><pre><code class="language-julia hljs">@constraints begin
    q(w) = q(w[begin])..q(w[end])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraints: 
  q(w) = q(w[(begin)..(end)])
</code></pre><h2 id="Default-constraints"><a class="docs-heading-anchor" href="#Default-constraints">Default constraints</a><a id="Default-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Default-constraints" title="Permalink"></a></h2><p>Sometimes, a submodel is used in multiple contexts, on multiple levels of hierarchy and in different submodels. In such cases, it becomes cumbersome to specify constraints for each instance of the submodel and track its usage throughout the model. To alleviate this, <code>RxInfer</code> allows users to specify default constraints for a submodel. These constraints will be applied to all instances of the submodel unless overridden by specific constraints. To specify default constraints for a submodel, override the <code>GraphPPL.default_constraints</code> function for the submodel:</p><pre><code class="language-julia hljs">RxInfer.GraphPPL.default_constraints(::typeof(inner)) = @constraints begin
    q(α) :: PointMassFormConstraint()
    q(α, β) = q(α)q(β)
end</code></pre><p>More information can be found in the <a href="https://reactivebayes.github.io/GraphPPL.jl/stable/plugins/constraint_specification/#Default-constraints">GraphPPL documentation</a>.</p><h2 id="Constraints-on-the-data"><a class="docs-heading-anchor" href="#Constraints-on-the-data">Constraints on the data</a><a id="Constraints-on-the-data-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints-on-the-data" title="Permalink"></a></h2><p>By default, <code>RxInfer</code> assumes that, since the data comes into the model as observed, the posterior marginal distribution of the data is independent from other marginals and is a Dirac-delta distribution. However, this assumption breaks when we pass missing data into our model. When the data is missing, we might have a joint dependency between the data and latent variables, as the missing data essentially behaves as a latent variable. In such cases, we can wrap the data in a <code>UnfactorizedData</code>. This will notify the inference engine that the data should not be factorized out and we can specify a custom factorization constraint on these variables using the <code>@constraints</code> macro. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RxInfer.UnfactorizedData" href="#RxInfer.UnfactorizedData"><code>RxInfer.UnfactorizedData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnfactorizedData{D}</code></pre><p>A wrapper struct to wrap data that should not be factorized out by default during inference. When performing Bayesian Inference with message passing, every factor node contains a local factorization constraint on the variational posterior distribution. For data, we usually regarding data as an independent component in the variational posterior distribution. However, in some cases, for example when we are predicting data, we do not want to factorize out the data. In such cases, we can wrap the data with <code>UnfactorizedData</code> struct to prevent the factorization and craft a custom node-local factorization with the <code>@constraints</code> macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/RxInfer.jl/blob/f81df47f1e3b2d4d9e68984e1f77ed6aefe9b6ba/src/model/model.jl#L10-L20">source</a></section></article><pre><code class="language-julia hljs">unfactorized_example_constraints = @constraints begin
    q(y[1:1000], μ, τ) = q(y[1:1000])q(μ)q(τ)
    q(y[1001:1100], μ, τ) = q(y[1001:1100], μ)q(τ)
end
result = infer(
    model       = iid_normal(),
    data        = (y = UnfactorizedData(vcat(rand(NormalMeanPrecision(3.1415, 2.7182), 1000), [missing for _ in 1:100])),),
    constraints = unfactorized_example_constraints,
    initialization = init,
    iterations = 25
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inference results:
  Posteriors       | available for (μ, τ)
  Predictions      | available for (y)
</code></pre><h2 id="prespecified-constraints"><a class="docs-heading-anchor" href="#prespecified-constraints">Prespecified constraints</a><a id="prespecified-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#prespecified-constraints" title="Permalink"></a></h2><p><code>GraphPPL</code> exports some <a href="https://reactivebayes.github.io/GraphPPL.jl/stable/plugins/constraint_specification/#Prespecified-constraints">prespecified constraints</a> that can be used in the <code>@constraints</code> macro, but these constraints can also be passed as top-level constraints in the <code>infer</code> function. For example, to specify a mean-field assumption on all variables in the model, we can use the <code>MeanField</code> constraint:</p><pre><code class="language-julia hljs">result = infer(
    model       = iid_normal(),
    data        = (y = rand(NormalMeanPrecision(3.1415, 2.7182), 1000), ),
    constraints = MeanField(), # instead of using `@constraints` macro
    initialization = init,
    iterations  = 25
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inference results:
  Posteriors       | available for (μ, τ)
</code></pre><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model-specification/">« Model specification</a><a class="docs-footer-nextpage" href="../meta-specification/">Meta specification »</a><div class="flexbox-break"></div><p class="footer-message">Created in <a href="https://biaslab.github.io/">BIASlab</a>, maintained by <a href="https://github.com/ReactiveBayes">ReactiveBayes</a>, powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 13 March 2025 09:52">Thursday 13 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
