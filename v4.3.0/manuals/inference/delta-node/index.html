<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Deterministic nodes · RxInfer.jl</title><meta name="title" content="Deterministic nodes · RxInfer.jl"/><meta property="og:title" content="Deterministic nodes · RxInfer.jl"/><meta property="twitter:title" content="Deterministic nodes · RxInfer.jl"/><meta name="description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="og:description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="twitter:description" content="Julia package for automated Bayesian inference on a factor graph with reactive message passing"/><meta property="og:url" content="https://docs.rxinfer.com/stable/manuals/inference/delta-node/"/><meta property="twitter:url" content="https://docs.rxinfer.com/stable/manuals/inference/delta-node/"/><link rel="canonical" href="https://docs.rxinfer.com/stable/manuals/inference/delta-node/"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-X4PH160GMF"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-X4PH160GMF', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/theme.css" rel="stylesheet" type="text/css"/><link href="../../../assets/header.css" rel="stylesheet" type="text/css"/><script src="../../../assets/header.js"></script><script src="../../../assets/chat.js"></script><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/><meta name="keywords" content="Julia, Bayesian inference, factor graph, message passing, probabilistic programming, reactive programming, RxInfer">
<link rel="sitemap" type="application/xml" title="Sitemap" href="https://docs.rxinfer.com/stable/sitemap.xml"></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img class="docs-light-only" src="../../../assets/logo.svg" alt="RxInfer.jl logo"/><img class="docs-dark-only" src="../../../assets/logo-dark.svg" alt="RxInfer.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../../getting-started/">Getting started</a></li><li><a class="tocitem" href="../../comparison/">RxInfer.jl vs. Others</a></li><li><a class="tocitem" href="../../model-specification/">Model specification</a></li><li><a class="tocitem" href="../../constraints-specification/">Constraints specification</a></li><li><a class="tocitem" href="../../meta-specification/">Meta specification</a></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox" checked/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Inference specification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../static/">Static inference</a></li><li><a class="tocitem" href="../streamlined/">Streamline inference</a></li><li><a class="tocitem" href="../initialization/">Initialization</a></li><li><a class="tocitem" href="../autoupdates/">Auto-updates</a></li><li class="is-active"><a class="tocitem" href>Deterministic nodes</a><ul class="internal"><li><a class="tocitem" href="#Features-and-Supported-Inference-Scenarios"><span>Features and Supported Inference Scenarios</span></a></li><li><a class="tocitem" href="#Gaussian-Case"><span>Gaussian Case</span></a></li><li><a class="tocitem" href="#Exponential-Family-Case"><span>Exponential Family Case</span></a></li><li><a class="tocitem" href="#Fuse-deterministic-nodes-with-stochastic-nodes"><span>Fuse deterministic nodes with stochastic nodes</span></a></li></ul></li><li><a class="tocitem" href="../nonconjugate/">Non-conjugate inference</a></li><li><a class="tocitem" href="../undefinedrules/">Undefined message update rules</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Inference customization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../customization/custom-node/">Defining a custom node and rules</a></li><li><a class="tocitem" href="../../customization/postprocess/">Inference results postprocessing</a></li></ul></li><li><a class="tocitem" href="../../debugging/">Debugging</a></li><li><a class="tocitem" href="../../session_summary/">Session summary</a></li><li><a class="tocitem" href="../../telemetry/">Sharing sessions &amp; telemetry</a></li><li><a class="tocitem" href="../../migration-guide-v2-v3/">Migration from v2 to v3</a></li><li><input class="collapse-toggle" id="menuitem-2-12" type="checkbox"/><label class="tocitem" for="menuitem-2-12"><span class="docs-label">Sharp bits of RxInfer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../sharpbits/overview/">Overview</a></li><li><a class="tocitem" href="../../sharpbits/rule-not-found/">Rule Not Found Error</a></li><li><a class="tocitem" href="../../sharpbits/stack-overflow-inference/">Stack Overflow in Message Computations</a></li><li><a class="tocitem" href="../../sharpbits/usage-colon-equality/">Using <code>=</code> instead of <code>:=</code> for deterministic nodes</a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../../library/model-construction/">Model construction</a></li><li><a class="tocitem" href="../../../library/bethe-free-energy/">Bethe Free Energy</a></li><li><a class="tocitem" href="../../../library/functional-forms/">Functional form constraints</a></li><li><a class="tocitem" href="../../../library/exported-methods/">Exported methods</a></li></ul></li><li><a class="tocitem" href="../../../examples/overview/">Examples</a></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="../../../contributing/guide/">Contribution guide</a></li><li><a class="tocitem" href="../../../contributing/guidelines/">Contribution guidelines</a></li><li><a class="tocitem" href="../../../contributing/new-documentation/">Contributing to the documentation</a></li><li><a class="tocitem" href="../../../contributing/new-example/">Contributing to the examples</a></li><li><a class="tocitem" href="../../../contributing/new-release/">Publishing a new release</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User guide</a></li><li><a class="is-disabled">Inference specification</a></li><li class="is-active"><a href>Deterministic nodes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Deterministic nodes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/RxInfer.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/RxInfer.jl/blob/main/docs/src/manuals/inference/delta-node.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="delta-node-manual"><a class="docs-heading-anchor" href="#delta-node-manual">Deterministic nodes</a><a id="delta-node-manual-1"></a><a class="docs-heading-anchor-permalink" href="#delta-node-manual" title="Permalink"></a></h1><p>RxInfer.jl offers a comprehensive set of stochastic nodes, primarily emphasizing distributions from the exponential family and related compositions, such as Gaussian with controlled variance (GCV) or autoregressive (AR) nodes. The <code>DeltaNode</code> stands out in this package, representing a deterministic transformation of either a single random variable or a group of them. This guide provides insights into the <code>DeltaNode</code> and its functionalities.</p><h2 id="Features-and-Supported-Inference-Scenarios"><a class="docs-heading-anchor" href="#Features-and-Supported-Inference-Scenarios">Features and Supported Inference Scenarios</a><a id="Features-and-Supported-Inference-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Features-and-Supported-Inference-Scenarios" title="Permalink"></a></h2><p>The delta node supports several approximation methods for probabilistic inference. The desired approximation method depends on the nodes connected to the delta node. We differentiate the following deterministic transformation scenarios:</p><ol><li><strong>Gaussian Nodes</strong>: For delta nodes linked to strictly multivariate or univariate Gaussian distributions, the recommended methods are <code>Linearization</code> or <code>Unscented</code> transforms.</li><li><strong>Exponential Family Nodes</strong>: For the delta node connected to nodes from the exponential family, the <code>CVIProjection</code> (Conjugate Variational Inference) is the method of choice.</li><li><strong>Stacking Delta Nodes</strong>: For scenarios where delta nodes are stacked, either <code>Linearization</code>, <code>Unscented</code> or <code>CVIProjection</code> are suitable.</li><li><strong>Support for Inverse Functions</strong>: For scenarious, where an inverse function is available</li></ol><p>The table below summarizes the features of the delta node in RxInfer.jl, categorized by the approximation method:</p><table><tr><th style="text-align: right">Methods</th><th style="text-align: right">Gaussian Nodes</th><th style="text-align: right">Exponential Family Nodes</th><th style="text-align: right">Stacking Delta Nodes</th><th style="text-align: right">Inverse functions</th></tr><tr><td style="text-align: right">Linearization</td><td style="text-align: right">✓</td><td style="text-align: right">✗</td><td style="text-align: right">✓</td><td style="text-align: right">✓</td></tr><tr><td style="text-align: right">Unscented</td><td style="text-align: right">✓</td><td style="text-align: right">✗</td><td style="text-align: right">✓</td><td style="text-align: right">✓</td></tr><tr><td style="text-align: right">CVI (deprecated)</td><td style="text-align: right">✓</td><td style="text-align: right">✓</td><td style="text-align: right">✗</td><td style="text-align: right">✗</td></tr><tr><td style="text-align: right">CVI Projection</td><td style="text-align: right">✓</td><td style="text-align: right">✓</td><td style="text-align: right">✓</td><td style="text-align: right">✗</td></tr></table><h2 id="Gaussian-Case"><a class="docs-heading-anchor" href="#Gaussian-Case">Gaussian Case</a><a id="Gaussian-Case-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-Case" title="Permalink"></a></h2><p>In the context of Gaussian distributions, we recommend either the <code>Linearization</code> or <code>Unscented</code> method for delta node approximation. The <code>Linearization</code> method provides a first-order approximation, while the <code>Unscented</code> method delivers a more precise second-order approximation. It&#39;s worth noting that while the <code>Unscented</code> method is more accurate, it may require hyperparameters tuning. In addition, both methods are working well when the function is differentiable. The results may not be accurate if the function is not differentiable.</p><p>For clarity, consider the following example:</p><pre><code class="language-julia hljs">using RxInfer

@model function delta_node_example(z)
    x  ~ Normal(mean = 0.0, var = 1.0)
    y := tanh(x)
    z  ~ Normal(mean = y, var = 1.0)
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>While not strictly required, it is advised to use <code>:=</code> to define a deterministic relationship within the <code>@model</code> macro.</p></div></div><p>To perform inference on this model, designate the approximation method for the delta node (here, the <code>tanh</code> function) using the <code>@meta</code> specification:</p><pre><code class="language-julia hljs">delta_meta = @meta begin
    tanh() -&gt; Linearization()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Meta: 
  tanh() -&gt; Linearization()
</code></pre><p>or</p><pre><code class="language-julia hljs">delta_meta = @meta begin
    tanh() -&gt; Unscented()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Meta: 
  tanh() -&gt; Unscented{Float64, Float64, Float64, Nothing}(0.001, 2.0, 0.0, nothing)
</code></pre><p>For a deeper understanding of the <code>Unscented</code> method and its parameters, consult the docstrings.</p><p>Given the invertibility of <code>tanh</code>, indicating its inverse function can optimize the inference procedure:</p><pre><code class="language-julia hljs">delta_meta = @meta begin
    tanh() -&gt; DeltaMeta(method = Linearization(), inverse = atanh)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Meta: 
  tanh() -&gt; DeltaMeta{Linearization, typeof(atanh)}(Linearization(), atanh)
</code></pre><p>To execute the inference procedure:</p><pre><code class="language-julia hljs">result = infer(
    model = delta_node_example(),
    meta  = delta_meta,
    data = (z = 1.0,)
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inference results:
  Posteriors       | available for (y, x)
</code></pre><p>This methodology is consistent even when the delta node is associated with multiple inputs. For instance:</p><pre><code class="language-julia hljs">f(x, g) = x*tanh(g)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">@model function delta_node_example(z)
    x ~ Normal(mean = 1.0, var = 1.0)
    g ~ Normal(mean = 1.0, var = 1.0)
    y := f(x, g)
    z ~ Normal(mean = y, var = 0.1)
end</code></pre><p>The corresponding meta specification is:</p><pre><code class="language-julia hljs">delta_meta = @meta begin
    f() -&gt; DeltaMeta(method = Linearization())
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Meta: 
  f() -&gt; DeltaMeta{Linearization, Nothing}(Linearization(), nothing)
</code></pre><p>or simply</p><pre><code class="language-julia hljs">delta_meta = @meta begin
    f() -&gt; Linearization()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Meta: 
  f() -&gt; Linearization()
</code></pre><p>If specific functions outline the backward relation of variables within the <code>f</code> function, you can provide a tuple of inverse functions in the order of the variables:</p><pre><code class="language-julia hljs">f_back_x(out, g) = out/tanh(g)
f_back_g(out, x) = atanh(out/x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f_back_g (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">delta_meta = @meta begin
    f() -&gt; DeltaMeta(method = Linearization(), inverse=(f_back_x, f_back_g))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Meta: 
  f() -&gt; DeltaMeta{Linearization, Tuple{typeof(Main.f_back_x), typeof(Main.f_back_g)}}(Linearization(), (Main.f_back_x, Main.f_back_g))
</code></pre><h2 id="Exponential-Family-Case"><a class="docs-heading-anchor" href="#Exponential-Family-Case">Exponential Family Case</a><a id="Exponential-Family-Case-1"></a><a class="docs-heading-anchor-permalink" href="#Exponential-Family-Case" title="Permalink"></a></h2><p>When the delta node is associated with nodes from the exponential family (excluding Gaussians), the <code>Linearization</code> and <code>Unscented</code> methods are not applicable. In such cases, the CVI (Conjugate Variational Inference) is available. Here&#39;s a modified example:</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>CVIProjection</code> method is available only if <code>ExponentialFamilyProjection</code> package is installed in the current environment.</p></div></div><pre><code class="language-julia hljs">using RxInfer, ExponentialFamilyProjection

@model function delta_node_example1(z)
    x ~ Gamma(shape = 1.0, rate = 1.0)
    y := tanh(x)
    z ~ Bernoulli(y)
end</code></pre><p>The corresponding meta specification can be represented as:</p><pre><code class="language-julia hljs">delta_meta = @meta begin
    tanh() -&gt; CVIProjection()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Meta: 
  tanh() -&gt; CVIProjection{Random.MersenneTwister, Int64, Nothing, Nothing, ReactiveMP.ProposalDistributionContainer{Any}, FullSampling}(Random.MersenneTwister(42), 100, nothing, nothing, ReactiveMP.ProposalDistributionContainer{Any}(nothing), FullSampling(10))
</code></pre><p>Consult the <code>CVIProjection</code> docstrings for a detailed explanation of its hyper-parameters. Additionally, read the <a href="../nonconjugate/#inference-nonconjugate">Non-conjugate Inference</a> section.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>CVIProjection</code> method is an improved version of the now-deprecated <code>CVI</code> method. This new implementation features different hyperparameters, better accuracy, and improved stability.</p></div></div><h2 id="Fuse-deterministic-nodes-with-stochastic-nodes"><a class="docs-heading-anchor" href="#Fuse-deterministic-nodes-with-stochastic-nodes">Fuse deterministic nodes with stochastic nodes</a><a id="Fuse-deterministic-nodes-with-stochastic-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Fuse-deterministic-nodes-with-stochastic-nodes" title="Permalink"></a></h2><p>Read how to circumvent the need to define the meta structure and, instead, fuse the deterministic relation with a neighboring stochastic factor node in <a href="../undefinedrules/#inference-undefinedrules-fusedelta">this section</a>.</p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../autoupdates/">« Auto-updates</a><a class="docs-footer-nextpage" href="../nonconjugate/">Non-conjugate inference »</a><div class="flexbox-break"></div><p class="footer-message">Created in <a href="https://biaslab.github.io/">BIASlab</a>, maintained by <a href="https://github.com/ReactiveBayes">ReactiveBayes</a>, powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 12 March 2025 07:28">Wednesday 12 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
